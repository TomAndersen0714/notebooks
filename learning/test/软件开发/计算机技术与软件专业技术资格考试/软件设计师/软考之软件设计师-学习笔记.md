# 软考之软件设计师-学习笔记

## 软考考试介绍

软考考试是从国外引入的，考的是广度而非深度，与实际开发情况不同

教材只是当做字典翻阅，想要通过考试不能直接翻阅教材，按照视频过一遍知识点和知识体系，然后直接刷真题，了解题型

需要建立知识体系，分版块自查，要学会抓重点，抓弱点

考试形式：上午题，计算机与软件工程知识，150分钟，选择题，75道；下午题，软件设计，150分钟，填空、问答题，题型固定。上下午考试科目满分75分，及格分为45分

### 考点表格

**用于自查考试知识点，查漏补缺，抓重点，找弱点**

![image-20221014091504408](resources/images/考试学习笔记/image-20221014091504408.png)

![image-20221014091504408](resources/images/考试学习笔记/image-20221014091504408.png)

![image-20221014091709062](resources/images/考试学习笔记/image-20221014091709062.png)

## 软件设计师考前培训

### 1. 计算机组成与体系结构

#### 1.1 数据的表示

#### 1.2 进制的转换

**R进制转为十进制，使用`带权展开求和法`**，其具体操作为：将R进制数的每一位数值使用R<sup>k</sup>的形式表示，即幂（power）运算的底数是待转换数的进制R，指数为k，k与该数码在原进制数中到其小数点间隔的距离（间隔多少个数字）有关。当该位数码在小数点左边时，k为正，等于与小数点距离的数码个数；在小数点右边时，k为负，绝对值等于与小数点距离的数码个数+1。

![image-20221014093314170](resources/images/考试学习笔记/image-20221014093314170.png)

**十进制转换为R进制，使用`短除取余反转法`**，其具体操作如下

**PS：值得注意的是被除数一定要除尽，即最后的商一定要是0，才停止运算。**如下图中，当商为1时，还要继续除以2，商等于0，余数为1，即最后二进制数的首位

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093556127.png" alt="image-20221014093556127" style="zoom:80%;" />

**二进制、八进制、十六进制相互转换**，二进制转八进制，从低位每3位分割，高位补0，每个组合使**用`按权展开求和法`运算**所得，最终结果即为八进制数；二进制转换为十六进制，从低位每4为进行分割，高位补0，每个分割块**使用`按权展开求和法` 所得**，并将10~15转换为A~F，最终结果，即为十六进制结果。

**其他进制相互转换**，如M进制数值转换为N进制，则一般是将M进制数值使用**按权展开求和法**转换为10进制数，然后再将其转换为N进制，即使用10进制数作为中间结果。

#### 1.3 原码、反码、补码、移码

**原码**：使用固定数量的字节数表示数值的编码，左边首位bit为符号位，转换时符号位到首个为1的bit位之间，补零进行表示。如数值1，使用2个Byte表示的原码则为`0000 0001`，其中首位为符号位，`0`表示正，`1`表示负数，如数值-1的原码为`1000 0001`

**反码**：反码中，**正数的反码和原码完全相同**；**负数的反码，则是负数的原码转换而来，转换规则为，符号位不动，其他bit位按位取反。**其中，+1(0000 0001)和-1(1111 1110)的反码按位求和结果为`1111 1111`，即对应的原码为`1000 0000`，即为-0

**补码**：补码中，**正数的补码和反码（原码）完全相同**；**`负数的补码，是负数的反码+1所得`。**如-1的反码为`1111 1110`，-1的补码为`1111 1111`，+1的补码为`0000 0001`，+1和-1的补码按位求和结果为`0000 0000`，即为+0

**移码**：**`移码中，正负数的移码都等于其对应补码，将首位符号反转后的结果`**。如-1的补码是`1111 1111`，移码则是`0111 1111`，而+1的移码则是`1000 0001`，两者按位求和的结果为`1000 0000`，即此结果移码对应的原码是`0000 0000`，即为+0

![image-20221017224303175](resources/images/考试学习笔记/image-20221017224303175.png)

**各编码表示的数值范围**：

由于补码中，正负0都是使用`0000 0000`表示的（假设为支持使用2 bytes保存），因此其表示的范围要比原码和反码大1个

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224554747.png" alt="image-20221017224554747" style="zoom: 50%;" />

#### 1.4 浮点数运算

个人理解，应该是先将各个浮点数**`采用科学计数法进行格式化`**，然后再进行**`对阶`**，即移动尾数的小数点，增加指数位的值，直到等于各个待求和数值中的指数的最大者，最后再进行**`尾数求和运算`**。

![image-20221017224932472](resources/images/考试学习笔记/image-20221017224932472.png)

![image-20221017224932472](resources/images/考试学习笔记/image-20221017224932472.png)

#### 1.5 计算机结构

**冯诺依曼体系结构**：计算机由五个部分组成，分别是**运算器、控制器、存储器、输入设备、输出设备**，并且采用二进制逻辑、程序存储执行。

其中CPU主要由运算器和控制器组成，而**`运算器`主要由算术逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR、状态条件寄存器PSW**等组成，**`控制器`主要是由程序计数器PC、指令寄存器IR、指令译码器ID、地址寄存器AR、时序部件**等组成。

**PS：指令(instruction), 寄存器(register)，地址(address), 译码器(decoder)**

#### 1.6 Flynn分类法

每个指令流则对应一个控制部分，每个数据流则对应一个处理器

SIMD(Single Instruction Multiple Data)，主要适用于数组运算，即对多个相同数据，使用统一指令进行处理

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017230941961.png" alt="image-20221017230941961" style="zoom: 80%;" />

#### 1.7 CISC与RISC

主要通过选择考察特点，直接理解记忆即可

CISC(Complex Instruction Set Computer, 复杂指令集计算机)

RISC(Reduced Instruction Set Computer, 精简指令集计算机), RISC的基本思想是通过减少指令总和和简化指令功能降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的速度，采用硬布线控制逻辑优化编译程序。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231217404.png" alt="image-20221017231217404" style="zoom: 80%;" />

#### 1.8 流水线和相关计算

类比于福特汽车工厂在组装汽车时，使用流水线的形式进行装配，汽车组装时每个人仅负责流水线上的单个部件安装，然后在流水线上流转到下一个专业员工面前，进行组装工作，提高整体效率。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231940470.png" alt="image-20221017231940470" style="zoom: 67%;" />

1. **流水线执行时间的计算：**

**`流水线的周期`**，其数值一般约**等于流水线上各个部分中，执行时间最长的部分的执行时间**，可以参考木桶原理，流水线上的各个部分需要等待耗时最长的部分结束，才能使得指令在流水线上进行流转

**执行时间计算公式**：

- **`理论公式`**：**`(t1+t2+t3...+ts)+(n-1)*T`**，即**等于顺序执行首个指令所花费的时间，与后续所有指令按流水线周期执行所花费的时间之和**，其中s表示单指令执行的步骤数量，ts表示第s阶段的耗费时间，而n表示流水线上需要处理的总指令数，T表示流水线周期，其中前一部分(t1+t2+t3...+ts)表示首条指令的完成耗时，后者(n-1)*T则表示

- **`实践公式`**：**`(s+n-1)*T`**，即**将单指令中各个执行部分的执行时间都视为等于流水线周期**，即最大部分的时间，然后进行计算

理论公式和实践公式的主要区别在于，首个指令的处理时间。在理论公式中，首个指令的处理时间是各个部分的时间之和，而在实践公式中，首个指令则是按照流水线周期乘以

**`优先使用理论公式，没有答案，则使用实践公式计算`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017233527423.png" alt="image-20221017233527423" style="zoom: 67%;" />

2. **流水线吞吐率TP(Though Put Rate)的计算：**

**`TP=指令条数/流水线执行时间`**

3. **流水线的加速比计算**

**`S=不使用流水线的执行时间/使用流水线的执行时间`**

不使用流水线时，则单个指令的执行完成时间，是各个执行部分时间开销的总和(t1+t2+...ts)，而所有指令的完成时间，则是**单指令完成时间之和乘以指令数量，即(t1+t2+...ts)*n**

4. **流水线的效率**

**流水线的效率是指流水线的设备利用率**。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比。

流水线效率的计算公式为：**`E = n个指令或任务占用的时空区/流水线中k个流水段的总的时空区`**

效率最高的流水线，是各个部分的工作时长完全相同，这样就能使得流水线上的任务不会去等待前置任务的结束，没有空闲

**PS：本节中需要学会手动绘制流水线时空图，以辅助理解各个计算公式。流水线效率，即阴影时空区的面积除以时空区总面积**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221019091751343.png" alt="image-20221019091751343" style="zoom: 67%;" />

#### 1.9 层次化存储结构

按照访问速度降序排序：寄存器（CPU）、Cache、内存、外存。一般情况下，存储空间的价格和访问速度成正相关，计算机中其存储空间也和访问速度成正相关。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085101810.png" alt="image-20221020085101810" style="zoom:80%;" />

#### 1.10 Cache

Cache的功能：提高CPU数据输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

在计算机的存储系统体系中，Cache是访问速度最快的层次。（**`寄存器不是最快的吗？？？？？`**）

使用Cache改善系统性能的依据是程序数据访问的局部性原理（locality）

**Cache+主存储器的平均周期计算**：

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085546877.png" alt="image-20221020085546877" style="zoom: 50%;" />

假设读取次数为n，则Cache+主存的读取周期计算公式为t3=(nht1+n(1-h)t2)/n=ht1+(1-h)t2，而不使用缓存的读取周期为t2

#### 1.11 局部性原理

局部性原理，又叫做**访问局部性(Locality of Reference), 数据局部性(Data Locality)**

局部性一般分为两类，空间局部性(spatial locality)和时间局部性(temporal locality)。**空间局部性指的是，访问一个数据之后，访问其存储空间及其临近的数据概率较大；时间局部性指的是，访问一个数据之后，后续临近的时间范围内，再次访问此数据的概率较大**。

#### 1.12 主存

**主存的分类**：

**随机存储存储器(RAM, Random Access Memory):** 断电后，存储内容丢失，如电脑内存

**只读存储器(ROM，Read Only Memory)**: 断点后，存储内容保留，如Bios中的存储器

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020090918987.png" alt="image-20221020090918987" style="zoom: 50%;" />

**主存编址**

**从内存寻址的角度来看：一块内存由许多个`内存地址单元`组成，支持按字节编址（即:8bit），或者按字编址（如:16bit），对应bit数量即为内存的字长，`内存的容量=内存的字长*内存地址单元数量`，内存地址单元数等于最大地址-最小地址+1，其中`内存地址通常为H后缀的16进制数`**

**从内存物理组成的角度来看：一块内存由许多片`存储芯片`组成，而一片存储芯片由多个`存储单元`组成，而每个存储单元，可以存储多个字节或bit位**

**由以上两点可以得出以下内存容量计算公式：**

**`内存的容量 = 内存的字长 * 内存地址单元数量 = 存储芯片数量 * 存储单元数量`**

PS：1K=1024=2^10

#### 1.13 磁盘工作原理

磁盘由磁道、扇区、磁头、磁柱等组成，磁道是磁盘上的一个个圆环，而扇区则是磁盘上的一个个扇形区间，两者共同定位一块磁盘存储物理块

**存取时间 = 寻道时间 + 等待时间(平均定位时间+转动延迟)**

寻道时间是指磁头移动到指定磁道所需的时间；等待时间为等待读写的扇区转动到磁头下方所需的时间。

**解题要点**：

1. **`磁道的磁头在寻址时，只会是朝着同一个方向持续旋转，不会逆向`**
2. **`磁道的磁头在寻址时，可以读取对应的数据写入到缓冲区，读取完成后才会处理缓冲区中的数据，且两者无法同时进行`**
3. **`在处理缓冲区的数据时，磁盘会继续匀速转动，扫描磁道`**
4. **题目中的“`最长时间`”的情况是每次刚刚处理完缓冲区数据时，磁头恰好扫到了下一个待读取扇区的结尾，需要再轮转一圈，才能扫描至其开头进行对应扇区数据的读取；而“`最短时间`”的情况是每次处理完缓冲区数据时，磁头切好扫到了下一个待读取扇区的开头**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020224432013.png" alt="image-20221020224432013" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020225809802.png" alt="image-20221020225809802" style="zoom:50%;" />

#### 1.14 计算机总线

**总线：内部总线、系统总线、外部总线**

**系统总线：数据总线、地址总线、控制总线**

#### 1.15 系统可靠性分析

**串联系统模型：**

**`可靠率` = R1\*R2\*R2\*R3...**

**`失效率` = λ1+λ2+λ3+λ4...**

**并联系统模型：**

![image-20221020230938442](resources/images/考试学习笔记/image-20221020230938442.png)

**模冗余模型：**

![image-20221020231303278](resources/images/考试学习笔记/image-20221020231303278.png)

**`串并联模型`：**

**解题要点：**

1. **注意观察整体是并联还是串联。然后划分各个子模块，计算各个子模块的可靠率**
2. **最后再按照整体的串联或并联公式进行计算整体的可靠率。**

![image-20221020231330512](resources/images/考试学习笔记/image-20221020231330512.png)

#### 1.16 校验码

**`码距`：两个二进制码字之间的码距，即两个二进制编码之间不同的bit位**，或者说通过变换二进制bit位，从一个二进制编码变换到另一个二进制编码时，所需要的变换bit位个数。

**检错码：即支持检查错误的编码方案。在一个码字内为了检错e个误码，要求最小的码距应该满足：`d>=e+1`**

**纠错码：即支持纠正错误的编码方案。在一个码字内为了纠错t个误码，则要求最小的码距应该满足：`d>=2t+1`**

**奇校验码和偶校验码：**奇偶校验码是通过在原码指定位置(通常是头部或尾部)添加0或1bit，使得整体bit位的异或结果为1或者0(即数值为1的bit个数为奇数，或者为偶数)

**`循环校验码(Cyclic Check Code, CRC)`: 是检错码，不是纠错码，支持1 bit位检错**

**`模2除法`，在除法的基础上，采取不借位的方式，即直接采用异或的方式，代替除法之中的借位和减法**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020234032568.png" alt="image-20221020234032568" style="zoom:67%;" />

**`循环校验码(CRC)的计算`：**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020234748858.png" alt="image-20221020234748858" style="zoom: 50%;" />

**`解题要点`：**

1. **基于`生成多项式`，生成二进制除数**。如生成多项式x^4+x^3+x+1转换成对应的二进制除数为`11011`，
2. 基于除数，**对被除数(即原始编码的二进制形式)进行尾部补零**，补零的个数为除数的位数减一，如除数为`11011`就需要对原始编码的二进制值尾部补4个零
3. **使用模2除法，求得最后的余数**
4. **使用余数的最后几位替换之前原始编码尾部补零的bit位**，最后生成的结果即CRC编码结果

**`校验CRC编码是否正确`:**

**将接收到的CRC编码作为被除数，基于约定的`生成多项式`生成对应的二进制除数，使用除数对被除数进行模2除法，如果最后余数为0，则表示CRC编码的结果是正确的，反之则错误**

**`海明码(Hamming code)`: 即是校验码，也是纠错码。海明码存在`校验位`和`信息位`，信息位依次存储原始信息码的bit，校验位则用于校验和纠错，且校验位和信息位的分布是固定的，唯有长度不固定。**

**海明码支持2 bit位的检错，支持1 bit位的纠错**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221021085444721.png" alt="image-20221021085444721" style="zoom:67%;" />

**海明码中`校验码长度满足公式`: `2^r>=x+r+1`，PS：其中r是海明码中校验位长度，x是海明码中二进制信息位的长度**。PS：其中x+r表示其中只有1位bit出错的情况数量，1表示全部正确的情况数量，2^r则表示r位校验位可以表示的所有情况

**海明码中`校验码分布公式`：`Pi = 2^i`，即在从低位开始的序号为2^0,2^1,2^2...的bit位置上，最低位序号为1**

**海明码中`校验位与信息位之间的联系`：若将海明码中各个bit位，从1开始进行二进制编号，则每个校验位的二进制序号可以是`1000, 0100, 0010, 0001`等，即序号的二进制值上只有某个bit为1，而这些校验码等于所有相同bit位上为1的序号，对应的信息位的异或之和，以此就可以列出校验位和信息位之间的`异或关系多项式`。**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221023105125863.png" alt="image-20221023105125863" style="zoom:50%;" />

**`基于信息码计算海明码要点`: **

1. **通过长度计算公式`2^r>=x+r+1`，确定海明码的长度范围，然后选择一个符合的海明码长度，一般取最短**
2. **基于海明码的长度，以及校验码分布公式`Pi = 2^i`，确定海明码中所有信息位和校验位的分布**
3. **基于海明码中`校验位与信息位之间的联系(校验位的值等于各个编号的对应bit位上为1的编号对应的数据位的异或之和)`，列出两者之间异或关系多项式**
4. **对于`异或关系多项式进行求解`，求得各个校验位，将校验位放置于对应位置上，即可求得最终的海明校验码**

### 2. 操作系统

#### 2.1 操作系统的概念

**操作系统的概念及其其主要作用：`进程管理、存储管理、文件管理`、作业管理、设备管理、`微内核操作系统`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221023105823261.png" alt="image-20221023105823261" style="zoom:67%;" />

#### 2.2 进程的管理

##### 2.2.1 进程的状态

**三态模型，五态模型**，要点在于（人为）挂起和激活会使得进程状态在活跃就绪、活跃阻塞与静止就绪、静止阻塞之间切换。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221024230059378.png" alt="image-20221024230059378" style="zoom: 67%;" />

##### 2.2.2 `前趋图`

**前趋图是用来表示，整个任务中各个环节之间的依赖关系，即有向无环图DAG(Directed Acyclic Graph)**

##### 2.2.3 进程的同步和互斥

同步的反义词是异步，互斥的反义词是共享。

**`互斥`，指的是相同角色之间对于临界资源的竞争；`同步`，指的是不同角色之间的相互等待。**

**以`生产者、缓冲区、消费者`三者举例，缓冲区作为临界资源，每次只能有一个生产者访问缓冲区，即`互斥`；每次生产者给缓冲区填充完成之后，必须等待消费者将其中的数据消费完成后，生产者才能继续填充，这是`同步`**。

##### 2.2.4 pv操作

**临界资源**：诸多相同进程角色间需要互斥方式访问的共享资源，如打印机、独木桥等

**临界区**：每个进程中访问临界资源的一段代码，被称为临界区

**缓冲区资源**：不同进程角色之间可以同时访问的共享资源，如写入缓冲区、桥梁等

**缓冲区：**

**信号量（signal）**：是一种特殊的变量，用于标识和传递特定的信号

**PV操作**：PV操作是由P操作原语和V操作原语组成，而操作的对象则是信号量，如：P(S)代表将信号量S-1，V(S)代表将信号量S+1。

**`PV操作关键要点`**：

1. **在执行P(S)操作后，信号量S-1，若信号量S>=0，则该进程会继续执行后续代码；若信号量S<0，则执行P(S)的进程会被阻塞，并加入到进程等待队列中，等待唤醒。**
2. **在执行V(S)操作后，信号量S+1，若信号量S>0，则该进程会继续执行后续代码；若信号量S<=0，则执行V(S)的进程会被阻塞，并唤醒进程等待队列中的首个生产者进程，让其从阻塞的命令处继续向后执行。**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221024232936770.png" alt="image-20221024232936770" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221024233824992.png" alt="image-20221024233824992" style="zoom:67%;" />

**`解题关键要点(？？？？)`**

1. **首先要`区分临界资源和缓冲区资源及其容量`，临界资源的互斥问题，其中PV操作以奇数对出现；缓冲区资源的同步问题，其中的PV操作以偶数对出现。**
2. **`基于PV操作后信号量状态，判断是否符合实际需求`。P操作后，如果S<0，则进入阻塞队列等待，否则继续执行；V操作后，如果S<=0，则唤醒阻塞队列中的首个进程，使其继续执行，否则当前进程继续执行**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025003200526.png" alt="image-20221025003200526" style="zoom:50%;" />

**`PV操作和前趋图组合：`**

1. **`在前趋图中可以简单理解，P是消耗上一个节点传来的信号量，而V则是通知下一个节点，可以继续执行了`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025003834432.png" alt="image-20221025003834432" style="zoom:50%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025004205653.png" alt="image-20221025004205653" style="zoom: 67%;" />

##### 2.2.5 死锁问题

**死锁(deadlock)**，如果一个进程在等待一件不可能发生的事情（如：等待一种不可能分配到的资源），则进程出现了死锁。而如果一个或多个进程产生死锁，则会造成系统死锁。

**`系统不会产生死锁的最小资源量计算`：`(n1-1)+(n2-1)+...+(nk-1)+1`，其中k为模块或进程个数，nk表示第k个模块或进程所需的资源数量。**

**死锁产生的四个条件**：

1. 资源互斥
2. 资源保持
3. 资源环路等待
4. 不剥夺其他已分配资源

##### 2.2.6 银行家算法

银行家算法分配资源的原则：

1. 当一个进程对资源的最大需求量不超过系统中的资源数时，可以接纳该进程
2. 进程可以分期请求资源，但请求的总数不能超过最大需求量
3. 当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里面得到资源

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025005144916.png" alt="image-20221025005144916" style="zoom:67%;" />

**`解题关键要点`：**

1. **根据各个进程的最大需求量和已分配资源，`计算进程剩余所需的各类资源`**
2. **根据原有的总资源数，以及各个进程已分配资源，`计算各类资源的剩余资源量`**
3. **通过各类资源的剩余资源量，和进程剩余所需的各类资源量，`筛选能够满足资源需求的进程`**
4. **`使用穷举法`，得出最后的分配方案**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025005958087.png" alt="image-20221025005958087" style="zoom:67%;" />

#### 2.7 存储管理

##### 2.7.1 内存分配

**`内存分配算法`：首次适应算法、最佳适应算法、最差适应算法、循环首次适应算法**

**首次适应算法(first Fit, FF)：将内存的空闲内存块，`按照地址大小升序排序`，确定优先级，当有进程申请内存时，则按照这个顺序，进行内存分配**

**最佳适应算法(best fit, BF)：将内存的空闲内存块，`按照空间大小升序排序`，确定优先级**

**最差适应算法(worst fit, WF)：将内存的空闲内存块，`按照空间大小降序排序`，确定优先级**

**循环首次适应算法(next fit, NF)：在寻找空闲空间时，`不再从表头开始寻找，而是继续从上一次找到的空闲块按地址升序查找`，直到找到第一个块满足的空闲内存块。此算法使得内存空间分布更加均匀，减小了查找空闲空间的开销，缺点是会缺少较大的空闲空间。**

##### 2.7.2 段页式存储

**`考点：`**

1. **逻辑地址和物理地址之间的转换**
2. **页式存储。段式存储、段页式存储的特点，以及运作方式**

###### 2.7.2.1 页式存储

**`逻辑地址`：页号+页内地址，`页表寄存器`：页表起始地址+页表长度，`物理地址`：内存真实的物理地址，`块号/页帧号+页内地址`，如`6A29H`**

**高级程序语言整体使用逻辑地址定位，加载到内存之后，在内存中是使用的是物理地址进行定位**

**`页式存储的作用？？？`**

**特点：使用页表存储逻辑页号，到物理页帧号（块号）的映射。每次将逻辑地址映射为物理地址时，先通过页表查询物理页帧号，然后使用页帧号替换逻辑页号即可**

优点：内存利用率高，碎片小，分配与管理简单

缺点：增加了系统开销，可能存在抖动现象（由于分配的内存小于程序所需内存空间，进而导致频繁的缺页中断和磁盘IO，使得页面调度时间，比进程实际运行时间要多）

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025091421734.png" alt="image-20221025091421734" style="zoom:67%;" />

**`解题要点`：**

1. **计算页表页内（页帧）地址的二进制长度**：页面大小（如：14K）代表页内地址所能表示的所有地址个数，故通过页表的大小可以确定其页内地址二进制长度，4K=4*2^10=2^12，即页内地址长度为12bit
2. 基于页内地址的长度，将**逻辑地址拆分为页号和页内地址（页帧地址）两个部分**
3. **基于页号查询页表获取页帧物理块号，将逻辑地址中的页号替换为页帧物理块号**，即为内存物理地址
4. **淘汰页面时，优先淘汰顺序页表中访问位为空的页号**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025092921644.png" alt="image-20221025092921644" style="zoom:67%;" />

###### 2.7.2.2 段式存储

**逻辑地址：`段号+段内地址`**

###### 2.7.2.3 段页式存储

###### 2.7.2.4 快表

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025093249913.png" alt="image-20221025093249913" style="zoom:80%;" />

##### 2.7.3 页面淘汰/页面置换算法

**缺页中断**：如果需要访问的内容不在内存中，需要去磁盘中读取和加载，则会发生缺页中断，需要保存当前运行环境，等到需要读取的内容加载完成之后再去恢复。

常见算法，**最优(Optimal, OPT)算法**，随机算法(RAND)

**`先进先出算法(First In First Out, FIFO)`**，当页面空间不足时，可能出现抖动

**`最近最少使用算法(Least Recently Used, LRU)`**，大多数情况下不会出现抖动，即当触发页面淘汰机制时，优先淘汰最久未访问的页面，PS：中文翻译不准确，中文应该翻译为**最久未使用算法**

**`FIFO算法`原理：按照元素访问的先后顺序，有序加入队列，先进入队列的元素，先出队淘汰**

**`LRU算法`原理：每次访问一个元素后，将元素放置于栈顶，后续栈满时，则将栈中最末尾的元素淘汰**

**`解题关键要点`：**

1. **毫无实际作用和逻辑，直接死记硬背，无需深究**
1. **如果说明是页式存储，则默认存在页表，出现缺页中断时，必然访问页表，即每次发生缺页中断访问物理地址时，都需要额外访问一次对应的页表**
1. **缺页中断是发生在指令执行期间，即指令运行过程中才能被称为缺页中断**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025222513148.png" alt="image-20221025222513148" style="zoom:67%;" />

#### 2.8 文件管理

##### 2.8.1 索引文件结构

直接索引、一级索引、二级索引、三级索引

**什么是逻辑块号，什么是物理块号？？？**

逻辑块号是有序的，对应着一段连续的逻辑地址；而物理块号，代表着实际（内存或磁盘）物理存储块的序号，通常无序的

**`解题关键要点`：**

1. **`连续的索引地址项，指向着一个个物理块的首地址，这些物理块在逻辑上连续，逻辑块号以编号0开始，但实际物理存储上不一定连续，即物理块号不连续`。如地址项iaddr[0]指向的是逻辑块0（的首地址），也是物理块50（的首地址）**
2. **`每个物理块，或者说逻辑块中，可以存放一定容量的信息，可以是下一级的索引块首地址项，也可以是数据块首地址项`。如：索引块和数据块的大小均为1KB大小，地址项大小为4B，则每个物理块（逻辑块）可以存放256个地址项，或者等长的数据**
3. **直接地址索引的索引物理块中存放的是物理块的首地址项，一级索引的索引物理块中，存放的是直接地址索引块的首地址，其他的索引则同样层层递进**
4. **`如果某个地址项，表示的是二级索引地址，则此地址项所在的物理块被称为二级地址索引表`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025234023249.png" alt="image-20221025234023249" style="zoom: 67%;" />

##### 2.8.2 文件和树形目录结构

**文件属性：只读属性(R)，存档属性(A)，系统文件(S)，隐藏文件(H)**

**文件名的组成：驱动器号、路径、主文件名、扩展名**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025234656483.png" alt="image-20221025234656483" style="zoom:50%;" />

##### 2.8.3 空闲存储空间的管理

空闲区表法、空闲链表法、**`位图法`**、成组链接法

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026001413515.png" alt="image-20221026001413515" style="zoom:50%;" />

**解题关键要点：**

1. **`字的起始序号是1，而bit位的位置起始序号为0`。都是没道理的，直接记住即可。**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026002026156.png" alt="image-20221026002026156" style="zoom:80%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026002315701.png" alt="image-20221026002315701" style="zoom:50%;" />

#### 2.9 设备管理

##### 2.9.1 数据传输控制方式

程序控制方式、程序中断方式、DMA方式、通道、输入输出处理机

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026002701178.png" alt="image-20221026002701178" style="zoom:67%;" />

##### 2.9.2 虚拟设备和SPOOLING技术

简单来说，就是使用缓存区，来避免资源争抢

##### 2.9.3 微内核操作系统

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026003349557.png" alt="image-20221026003349557" style="zoom:67%;" />

### 3. 数据库系统

#### 3.1 数据库模式

**`三级模式，两级映射`：外模式、概念模式、内模式；外模式-概念模式映射，概念模式-内模式映射**

**`内模式`，指的是数据库文件(file)的存储方式**

**`概念模式`，指的是数据库中表(table)的存储方式**

**`外模式`，指的是数据库提供给用户的视图(view)展示方式**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026003838351.png" alt="image-20221026003838351" style="zoom:67%;" />

#### 3.2 实体关系(ER)模型

##### 3.2.1 数据库设计过程

需求分析、概念模型、逻辑模型、物理模型

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026004313052.png" alt="image-20221026004313052" style="zoom:67%;" />

**ER图中包含`实体、属性、联系`三种类型模块，分别使用矩形、椭圆形、菱形来表示。联系，可以是1:1，1:n，m:n**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026004629262.png" alt="image-20221026004629262" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026004653875.png" alt="image-20221026004653875" style="zoom:67%;" />

**关系模式的转换**

**`解题关键要点`：**

1. 可以把关系模式视为数据库表，即一对一联系的实体，至少可以用两张表来存储，其中联系通过id的方式存储在任意一端即可，当然也可以单独存储联系，共使用三张表来表示。而一对多，则至少需要三张表来表示实体和关系。多对多，则也是至少需要三张表来表示实体和关系，否则会发生数据膨胀。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026005153286.png" alt="image-20221026005153286" style="zoom:67%;" />

#### 3.3 关系代数与元组演算

##### 3.3.1 关系代数

**并、交、差、`笛卡尔积、投影、选择、联接`**

**`笛卡尔积`：对两表中各行数据进行嵌套循环拼接，数量等于m\*n**

**`投影`：选择表的某一指定列作为结果**

**`选择`：选择表的某一满足条件的行作为结果**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026010107001.png" alt="image-20221026010107001" style="zoom:50%;" />

**`联接`：在笛卡尔积的计算逻辑基础上，筛选满足指定条件的拼接行作为结果**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026010203901.png" alt="image-20221026010203901" style="zoom:67%;" />

#### 3.4 规范化理论

##### 3.4.1 函数依赖

如：学号唯一确定学生姓名，学生姓名依赖于学号，但是学生姓名不能确定学号，因为学生姓名可能重复，一一映射才是函数依赖

**部分函数依赖**：AB组合中的部分属性，就能确定C

**传递函数依赖**：A确定B，B确定C，故A确定C

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026084800251.png" alt="image-20221026084800251" style="zoom: 67%;" />

**非规范化的关系模式，可能存在的问题包括：`数据冗余`、`更新异常`、`插入异常`、`删除异常`**

**逆规范化理论：当数据比较稳定，不需要进行更新、插入、删除时，则可以利用数据冗余，避免数据关联操作**

##### 3.4.2 键(key)

**`键(key)`：**

**超键：可以唯一标识一行记录，但超键除了包含主键外，还`可以包含某些多余的属性`**

**候选键：可以唯一标识一行记录，`但是不包含多余数据`，即最小的超键，一个表可以有多个候选键**

**主键：可以唯一标识一行记录，可以是一个列或多个列的组合，一个表只能有一个主键**

**外键：其他数据表中的主键**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026085436433.png" alt="image-20221026085436433" style="zoom:67%;" />

**`候选键求解关键点`：**

1. **函数依赖生成有向无环图DAG**
2. **寻找入度为0的结点，如果从该结点开始能够遍历图中所有结点，则其为候选键之一**
3. **若入度为0的结点无法遍历图中所有结点，则需要增加一些未能遍历到的结点，或者指向这些未遍历结点的结点**
4. **遇到相互依赖的情况，可以通过分别删除两者之间的一条依赖，来简化DAG，视为两种情况求解**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026090007035.png" alt="image-20221026090007035" style="zoom:80%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026090655371.png" alt="image-20221026090655371" style="zoom:67%;" />

##### 3.4.3 范式

**第一范式(1NF): 属性(列，域)只代表原子值，`每一个属性(列，域)都是不可再分的`。如：某数据表中的列，“教授”需要拆分为“教授”和“副教授”，才能满足第一范式**

**第二范式(2NF): 满足1NF，每一个非主(键)属性，完全依赖主键（`非主属性不存在部分函数依赖于键`）。**

**第三范式(3NF):  满足2NF，`非主属性不存在传递依赖于主键`**

**BC范式(BCNF): 满足3NF，且`任何属性（包括主属性）都不存在部分函数依赖和传递函数依赖`**

**PS：2NF和3NF指的是非主属性不存在部分函数依赖和传递函数依赖，BC范式指的是所有属性都不存在部分函数依赖和传递函数依赖**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026090858071.png" alt="image-20221026090858071" style="zoom:67%;" />

**数据规范化，主要是为了解决关系型模型中的插入异常、删除异常、更新异常、数据冗余的问题**

##### 3.4.4 关系模式分解

**保持函数依赖的分解**：分解前后，函数依赖不变

#### 3.5 并发控制

**`事务的四大特性`：ACID特性，原子性Atomicity，一致性Consistency，隔离性Isolation，持续性Duration**

**`并发操作可能产生的三大问题`：丢失更新、不可重复读、读脏数据**

**丢失更新：**若两线程同时读取相同的数据，线程A先提交更新，则线程B的提交给覆盖线程A的提交，即线程A的**更新丢失**

**不可以重复读：**若线程A连续读写两次，其中B在这之前读写了一次，则线程A会出现两次读取的值不同的情况，即**不可重复读**

**读脏数据：**若线程A先给一份数据赋值，但随后又回滚Rollback，则这之间线程B读取的数据就是**脏数据**，是无效的数据

**封锁协议：**

X是排它锁(exclusive lock)，S是共享锁(shared lock)

**一级封锁协议**：事务T在修改数据之前增加X锁

**二级封锁协议**：事务T在修改数据之前增加X锁，在读取数据之前增加S锁，读完时释放

**三级封锁协议**：事务T在修改数据之前增加X锁，在读取数据之前增加S锁，事务结束时释放

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026230004720.png" alt="image-20221026230004720" style="zoom:67%;" />

#### 3.6 数据完整性约束

**实体完整性约束：主数据需要完整，符合实际意义**

**参照完整性约束：参照数据需要完整，需要属于参照实体数据表中的数据**

**用户自定义完整性约束**

完全备份：备份所有数据

**差量备份：备份上一次完全备份之后变化的数据**

增量备份：备份上一次备份之后变化的数据（但是并不和之前的备份直接合并，而是单独存储）

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026231224868.png" alt="image-20221026231224868" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026231215990.png" alt="image-20221026231215990" style="zoom:67%;" />

#### 3.7 分布式数据库

#### 3.8 数据仓库和数据挖掘

面向主题、集成的、相对稳定的（非易失，不会频繁更新和修改）、反应历史变化

数据集市，即部门级别的数据仓库

#### 3.9 反规范化技术

由于规范化会使得表不断拆分，从而导致数据表过多。这样虽然减少了数据冗余，提高了增、删、改的速度，但是会增加查询的工作量。系统需要进行多次联接，才能进行查询操作，使得系统效率大大下降。

**PS：不同的技术，有不同的适应场景，这个世界没有银弹**

**常用的反规范化技术：**

1. 增加派生型冗余列（避免重复计算）
2. 增加冗余列（避免重复联接）
3. 重新组表
4. 分割表

#### 3.10 大数据技术

**4V特性**：Volume、Velocity、Variety、Value

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026233003425.png" alt="image-20221026233003425" style="zoom:67%;" />

### 4. 计算机网络

#### 4.1 OSI/RM七层网络模型

**应用层、表示层、会话层、传输层、网络层、数据链路层、物理层**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026233120039.png" alt="image-20221026233120039" style="zoom:80%;" />

**`解题关键要点`：**

1. （网络层）三层以下的设备都处于同一个局域网中，而三层及以上的网络设备，会划分子网网段，将其包含的设备分配在其下的局域网中
2. **IP全局广播只能在当前局域网中进行，无法传出到另一个网段中**
3. **网桥在以前是二层设备（实际上现在大部分都是三层设备）**

即答案选择B

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026233758071.png" alt="image-20221026233758071" style="zoom:80%;" />

#### 4.2 TCP/IP四层网络模型

TCP协议族都是可靠协议，而UDP协议族都是不可靠协议

**自底向上分别为，`网络接口层、网络层、传输层、应用层`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026234332360.png" alt="image-20221026234332360" style="zoom:80%;" />

##### 4.2.1 TCP协议

**传输控制协议(Transmission Control Protocol, TCP)**

**用户数据报协议(User Datagram Protocol, UDP)**

**`三握四挥`：**

![[image-20221026234551489.png]]

##### 4.2.2 DHCP协议

**动态主机配置协议(Dynamic Host Configuration Protocol)**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026234725387.png" alt="image-20221026234725387" style="zoom:67%;" />

##### 4.2.3 DNS协议

**域名服务器(Domain Name System)协议**

**迭代查询，递归查询**：逐级纵向遍历，统计横向遍历。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026235112253.png" alt="image-20221026235112253" style="zoom:67%;" />

**`关键解题要点`：**

1. **迭代查询是被请求方直接返回结果，而递归查询则是被请求方代理查询，并发起新的请求，然后才并返回查询结果结果**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026235656199.png" alt="image-20221026235656199" style="zoom:80%;" />

##### 4.2.4 计算机网络的分类

**按照分布范围来划分：**局域网、城域网、广域网、因特网

**按照拓扑结构来划分：**总线型、星型、环型

#### 4.3 网络规划与设计

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027000154305.png" alt="image-20221027000154305" style="zoom: 67%;" />

#### 4.4 IPv4

iPv4，是四个字节，32bit位

每类网络的固定前缀的编码都是完全相同的，各个不同类别网络的编码不同

1. **A类网络的网络地址固定为1字节（8bit位），主机地址固定为三字节（24bit位）**
2. **B类网络的网络地址固定为2字节（16bit位），主机地址为2字节（16bit位）**
3. **C类网络的网络地址固定为3字节（24bit位），而主机地址固定为1字节（8bit位）**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027000313248.png" alt="image-20221027000313248" style="zoom:67%;" />

**`子网掩码`，指的是对应网段IP地址前缀bit位全为1的IP地址码，如子网网段`168.195.216.0/21`的子网掩码是`255.255.248.0`，即21个连续bit位**

用子网掩码和IP地址进行按位与操作，可以快速得出IP地址是否属于同一个子网

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027001718263.png" alt="image-20221027001718263" style="zoom:67%;" />

**`解题关键要点`：**

1. **在按照网络类别划分网络时，网络地址的长度需要满足对应类别网络的要求**
2. **C类网络的网络地址固定为3字节（24bit位），而主机地址固定为1字节（8bit位）**
3. **A类网络的网络地址固定为1字节（8bit位），主机地址固定为三字节（24bit位）**
4. **B类网络的网络地址固定为2字节（16bit位），主机地址为2字节（16bit位）**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027002335247.png" alt="image-20221027002335247" style="zoom:67%;" />

**特殊含义的IP地址：**

**本地广播地址**：固定为，255.255.255.255

**定向广播地址**（特定子网的广播地址）：主机地址全为1，如给网段192.168.1.0/24的定向广播的地址为192.168.1.255

**PS：路由器（三层设备）不会转发本地广播地址，但是会转发定向广播地址**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027002714508.png" alt="image-20221027002714508" style="zoom:67%;" />

#### 4.5 HTML

**超文本标记语言(Hypertext Markup Language)**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027005223831.png" alt="image-20221027005223831" style="zoom:80%;" />

#### 4.6 无线网

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027005409135.png" alt="image-20221027005409135" style="zoom:80%;" />

#### 4.7 网络接入技术

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027005524297.png" alt="image-20221027005524297" style="zoom:67%;" />

#### 4.8 IPv6

**IPv4采用的是32位地址，而IPv6采用的是128位表示**

### 5. 系统安全分析与设计

#### 5.1 信息系统安全属性

保密性，完整性，可用性，不可依赖性

![image-20221027010333398](resources/images/考试学习笔记/image-20221027010333398.png)

#### 5.2 加密技术

**对称加密**
1. 即加密和解密用的是同一份密钥。**优点是速度快效率高，缺陷是加密程度不高**，且加密解密使用的密钥不适合分发。

**非对称加密**
1. 即加密和解密用的是不同的密钥，加密时使用的是接收方提供的公钥，则解密时需要接收方使用特定的私钥才能解密
2. 通常公钥是公开的，用于给客户端使用的。如果需要反向加密传输，则需要使用接收方提供的公钥
3. **优点是加密程度高，支持分发公钥，缺陷是速度慢**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027011153980.png" alt="image-20221027011153980" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027011130936.png" alt="image-20221027011130936" style="zoom:67%;" />

#### 5.3 消息摘要

常见的消息摘要算法有MD5，SHA(如SHA1,SHA5等)等单向散列函数，将一段信息或者一份文件进行哈希，生成固定长度的散列值，且**通常是不可逆的**，主要作用是**用于数据完整性校验**等，**其散列值被称为“信息摘要”**。

**通常发送方还会使用自己的私钥对消息摘要进行加密，进而生成`数字签名`**

#### 5.4 数字签名

**某一用户使用他的私钥加密明文后生成的密文，任何人都可以用该用户的公钥解密密文；由于私钥只由该用户自己持有，故可以肯定该文件必定出自于该用户**；公众可以验证该用户发布的数据或文件是否完整、中途有否曾被篡改，接收者可信赖这些数据、文件确实来自于该用户，这种加密后的密文被称为**数字签名**

即**数字签名，是使用私钥加密，使用公钥解密，目的是验证发送方的身份**。

数字签名的逻辑和非对称加密数据的逻辑不同，`数字签名使用私钥加密（即签名），公钥解密（即验签）；数据加密使用公钥加密，私钥解密`

**`数字签名的发送和接收过程`**：

**生成后的数字签名，会和原文一起发送给接收方，接收方在接收到带有数据签名的信息之后，会先使用公钥来解析出数字签名，然后使用相同的Hash算法对原文计算Hash值，并与数字签名使用公钥解密后的结果进行比较，如果相同，则表示原文没有发生修改，如果不同则表明原文发送了修改。**

**PS：数字签名使用的“原文”也可以是某种加密的密文，如，可以先对明文使用非对称算法的公钥进行加密，然针对密文使用数字签名**

#### 5.5 数字信封与PGP

**`数字信封`：即`同时使用随机对称加密，和非对称加密技术`，先将原始明文使用随机对称加密技术加密，然后将对称加密的密钥使用接收方的公钥加密，发送给接收方，接收方接收到后，先使用私钥解密对称加密算法的密钥，然后再去解密原始信息**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027012537509.png" alt="image-20221027012537509" style="zoom:67%;" />

**`解题关键要点`：????**

1. **待发送的明文需要使用随机密钥进行加密**
1. 消息摘要，需要使用私钥进行加密

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027012824850.png" alt="image-20221027012824850" style="zoom:67%;" />

#### 5.6 网络安全

##### 5.6.2 各个网络层次的安全保障

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027084254594.png" alt="image-20221027084254594" style="zoom:67%;" />

##### 5.6.2 网络威胁和攻击

**关键点：`长期窃听和分析，才是业务流分析`，而非简单的窃听**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027084846303.png" alt="image-20221027084846303" style="zoom:50%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027084817333.png" alt="image-20221027084817333" style="zoom: 50%;" />

##### 5.6.3 防火墙技术

**防火墙技术防外不防内**

**网络级：在网络层进行过滤和拦截，效率高**

**应用级：在应用层进行过滤和拦截，需要拆包和解析包，效率低**

**DMZ区域(非军事区, Demilitarized Zone)：通常存放不属于外网也不属于内网的机器，用于对外提供访问服务，如Web服务等，与内网隔绝**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027085056315.png" alt="image-20221027085056315" style="zoom: 67%;" />

### 6. 数据结构

#### 6.1 数据结构的定义

**线性结构：如数组、顺序表、链表等**

**非线性结构：如树、堆、图等，非线性结构可以包含线性结构**

#### 6.2 数组与矩阵

##### 6.2.2 数组

**`数组中元素地址的计算，关键解题要点`：**

1. **每个数组中，每个数组的起始地址，即对应数组名存储的地址（和C/C++中的概念相同）**
2. **每个数组的首个元素下标从0开始**
3. **二维数组中，按行（优先）存储和按列（优先）存储，即分别代表首个下标代表行号或者列号**
4. **计算完元素的偏移量之后，还需要乘以每个元素的长度，才能得出最终的地址（C/C++中会自动乘以元素长度）**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027090240916.png" alt="image-20221027090240916" style="zoom:67%;" />

##### 6.2.3 稀疏矩阵

稀疏矩阵：即矩阵中存在很多为空

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027090932174.png" alt="image-20221027090932174" style="zoom:67%;" />

**`稀疏矩阵地址解题计算要点`：**

1. **使用等差数列求和计算公式**
2. **需要注意映射数组的首个元素下标，如果未说明则下标从0开始，但有些题目下标是从1开始**
3. **不论是否推导出公式，都需要使用实际的元素代入进行验算或求解**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221027093650521.png" alt="image-20221027093650521" style="zoom:50%;" />

#### 6.3 线性表

**顺序表：存储空间连续的线性表**

**链表：单链表、循环链表、双向链表**

**`头结点的作用`：链表通常会引入头结点，头结点是一个指向链表起始元素的空结点，`引入的目的主要是为了使得链表中对各个结点的操作保持一致，不需要增加if等判断条件`**

**链表的基本操作**

1. **单链表删除操作：将an-1的next指针指向an的next，将an的next置为空**
2. **单链表插入操作：将an的next指针指向an-1的next，将an-1的next指向an**
3. **双向链表的删除操作**
4. **双向链表的插入操作**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221028085943195.png" alt="image-20221028085943195" style="zoom:67%;" />

#### 6.4 栈和队列

**循环队列中，通常会将最后一个元素空余，通过(tail+1)%size=head的方式来判断是否队满**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221028090209795.png" alt="image-20221028090209795" style="zoom: 67%;" />

**`双端队列解题关键要点`：**

1. **整体使用排除法**
2. **给双端队列输入元素时，e1和e2必定相邻，e1和e3要么相邻，要么间隔一个元素e1**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221028090840383.png" alt="image-20221028090840383" style="zoom:67%;" />

#### 6.5 广义表

**广义表是n个表元素组成的有序序列，是线性表的（递归）组合和推广**

**广义表可以嵌套广义表**

**广义表的深度：指的是普通线性表嵌套的层次，初始为1**

**广义表的长度：指的是最顶层元素的个数**

**广义表的基本操作：取表头元素head(Ls)，取表尾元素tail(Ls)，PS：`此处的取表尾元素指的是取所有非表头元素（纯理论直接记忆）`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221028091850832.png" alt="image-20221028091850832" style="zoom:67%;" />

#### 6.6 树与二叉树

##### 6.6.1 树的基本概念

**结点的度：某个结点的度，即其下一级孩子结点的个数**

**树的度：所有结点中结点的度的最大值，即为树的度**

**叶子结点：度的值为0的结点**

**分支结点：度的值大于1的结点**

**内部结点：非叶子结点，即为内部结点**

**兄弟结点：同一父亲下的同一层次的结点**

**`二叉树`：`树的度小于等于2的树`，即为二叉树**

**满二叉树：二叉树中每一层的结点数满足2^i-1(i=1,2...)**

**完全二叉树：二叉树中，除了最后一层，每一层的结点数满足2^i-1(i=1,2...)，且最后一层结点从左到右依次顺序排列，没有空缺**

**`二叉树的关键特性`**

1. **对于任何一颗二叉树，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029161454145.png" alt="image-20221029161454145" style="zoom:80%;" />

##### 6.6.2 二叉树的遍历

**前序遍历：先访问根结点，在访问左右子树根结点**

**中序遍历：先访问左子树根结点，再访问根结点，最后访问右子树根结点**

**后序遍历：先访问左右子树根结点，最后访问根结点**

**`关键要点`：**

1. **前中后序遍历的变化在于根结点，与左右子树根结点的相对顺序，左右子树根结点的遍历顺序整体不变**
2. **前序遍历结果中，首个结点代表根结点，且左右子树结点连续分布，如“ABHFDECG”中，A为根结点**
3. **中序遍历结果中，根结点所在的位置，将二叉树划分为左子树和右子树，如“HBEDFAGC”中，A为根，则将子树划分为HBEDF和GC**
4. **后序遍历结果中，最后一个遍历的结点代表根结点，且左右子树连续分布**

**`反向构造二叉树`**

**只要有`中序遍历结果`，和前序或后序遍历结果的一种进行组合，就能反向构造出二叉树，以及求解另一种遍历结果。因为中序遍历结果，决定了二叉树的子树分割，而前序和后序则决定了二叉树的根结点，两者结合，即确定了二叉树的整体形态**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029163935916.png" alt="image-20221029163935916" style="zoom:50%;" />

##### 6.6.3 普通树转二叉树

**层次遍历，首个结点作为父结点的左子树根结点，其余兄弟结点，依次成为前一个结点的右子树根节点**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029164319856.png" alt="image-20221029164319856" style="zoom:50%;" />

##### 6.6.4 查找二叉树

**查找二叉树（排序二叉树）：所有结点中左右结点按照值的大小排序(sorted)的二叉树，即为查找或排序二叉树**

插入顺序不同，生成的查找二叉树也不同

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029170444767.png" alt="image-20221029170444767" style="zoom:67%;" />

##### 6.6.5 最优二叉树(Huffman哈夫曼树)

**路径**：从一个结点到另一个结点之间的通路，**路径上的分支数目称为路径长度**

**树的路径长度**：从树**根结点到每一个叶子结点之间的路径长度之和**。

**结点的带权路径长度**：为从该结点到树根结点之间的路径长度，与该结点权值的乘积

**`树的带权路径长度`**：为树中**所有叶子结点的带权路径长度之和**

**最优二叉树(Huffman树)：是指树的带权路径长度最小的二叉树**

**`已知叶子结点及其权值，构建最优二叉树(Huffman树)的关键要点`：**

1. **每次将待处理的集合中，权值最小的两个结点的权值求和，并生成一个对应权值的虚拟父结点加入到待处理结点集合中，并将集合中这俩叶结点删除**
2. **重复上述过程，直到结点列表只剩下最后一个结点，即最优二叉树的带权路径长度**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029175212718.png" alt="image-20221029175212718" style="zoom:80%;" />

##### 6.6.6 线索二叉树

**线索二叉树：一般是利用空余的左右子树指针，将其按照某种遍历顺序（如前序、中序、后续等），将其指向前继结点，或后继结点，保留遍历时的顺序信息**

**`二叉树转换为线索二叉树关键要点`：**

1. 按照指定的遍历序列，在各个结点的左空指针和右空指针上，填写遍历的前继结点，或遍历的后继结点的指针

##### 6.6.7 平衡二叉树

**平衡二叉树：`任意结点的左右子树深度相差不超过1`的排序二叉树**

#### 6.7 图

##### 6.7.1 图的存储

有向图，无向图

**完全图：在无向图中，若每对顶点之间都有一条边相连，则称该图为无向完全图；在有向图中，若每对顶点之间都有两条有向边相互连接，则称该图为有向完全图；**

**邻接矩阵：**

使用二维矩阵存储图中两点之间的联系，Rij表示从顶点i到j是否存在联系

空间复杂度：O(n*n)

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029213101213.png" alt="image-20221029213101213" style="zoom: 50%;" />

**邻接表：**

邻接表的数组长度等于图中顶点个数

数组中存储着链表，链表中每个元素存储着出度顶点的指针、距离、以及下一个元素的指针

空间复杂度：O(m+n)，n为元素个数，m为边的个数

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029213159485.png" alt="image-20221029213159485" style="zoom:50%;" />

##### 6.7.2 图的遍历

**`深度优先遍历`：通常利用栈来实现，每次在pop元素之前，若该元素直接指向的元素还未遍历，则将其push到栈中，否则遍历对应的元素；持续这一动作，直到栈为空**

**`广度优先遍历`：通常利用队列来实现，每次poll完首个元素之后，将其指向的所有元素添加到队尾，然后继续遍历；持续这一动作，直到队列为空**

##### 6.7.3 拓扑排序

**`解题关键要点`：**

1. **每次去除入度为0的顶点，最后得出活动或任务的所有可行的拓扑排序**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029214315864.png" alt="image-20221029214315864" style="zoom:80%;" />

##### 6.7.4 图的最小生成树

图和树最大的区别在于

1. 图可以有环路，树不能有环路
2. 树的每个结点，只能有一个父亲

**生成树**：一个连通图的生成树，是该图的极小连通子图，若在图的生成树中任意增加一条边，则必然形成回路。

**最小生成树**：图的生成树并不是唯一的，如果生成树的各个边带有相应的权值，则生成树各边的权值总和被称为**生成树的权**，而权值最小的生成树被称为**最小生成树**

**`最小生成树求解算法`：**

**普利姆算法(Prim)**

将所有的顶点分为两个集合A和B，A初始为空，B中初始包含所有顶点。每次将A中指向B的边中最小边关联的顶点添加到A中，直到B为空，所得的边即组成最小生成树

**PS：Prim算法的关键在于选最近的点**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029220039632.png" alt="image-20221029220039632" style="zoom:50%;" />

**克鲁斯卡尔(Kruskal)**

将所有的边作为一个集合A和P，每次从A中取出一条最短且两端点不全都在P中的边，然后将A关联的点添加到P中，直到P中包含有所有顶点即可

**PS：Kruskal算法的关键在于选最短的边**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029220054365.png" alt="image-20221029220054365" style="zoom:50%;" />

### 7. 算法基础

**时间复杂度和空间复杂度，分别是算法占用的时间和空间资源，随着数据量变化的函数。**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029221222380.png" alt="image-20221029221222380" style="zoom:50%;" />

#### 7.1 查找

##### 7.1.1 顺序查找

将表中的元素从头到尾顺序查找，找到则返回成功，否则则继续查找，直到到达结尾，则返回失败。

**时间复杂度：O(n)，空间复杂度：O(1)**

##### 7.1.2 二分查找（折半查找）

使用二分查找法的前提是，查找的表中的内容是有序排列的，否则则无法使用二分查找

**时间复杂度：O(log<sub>2</sub>n)，空间复杂度：O(1)**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029222341015.png" alt="image-20221029222341015" style="zoom:67%;" />

##### 7.1.3 散列表查找

**散列冲突的解决方案：**

1. 线性探测法
2. 伪随机数法
3. 再散列

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029223936231.png" alt="image-20221029223936231" style="zoom:67%;" />

#### 7.2 排序

**稳定的排序**：排序键值相同的元素，其相对顺序，在排序前后不发生改变

**不稳定的排序**：排序键值相同的元素，其相对顺序，在排序前后可能发生改变

**内部排序**：即待排序记录全部存放在内存中进行排序的过程；外部排序：待排序元素的数据量很大，以致于内存不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程

**插入类排序**：直接插入排序、希尔排序

**交换类排序**：冒泡排序、快速排序

**选择类排序**：简单选择排序、堆排序

##### 7.2.1 直接插入排序

插入第i个记录时，R1、R2、Ri-1已经排好序（**插入前已排序**），这时将Ri的关键字ki与关键字ki-1，ki-2等**自后向前进行比较**，找到应该插入的位置，将插入位置之后的元素进行后移，然后插入第i个记录

**稳定排序，时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)**

##### 7.2.2 希尔排序

希尔排序，又叫做“缩小增量排序”，是**直接插入排序的改进版**。主要思想是，以一个逐步递减到1的序列作为步长（一般是除2向上取整），每次顺序遍历待排序序列，基于对应的步长进行分组，针对每个分组使用直接插入排序，最终到步长为1时，即每个元素为一组，进行直接插入排序。

**不稳定排序，时间复杂度O(n<sup>1.3</sup>)，空间复杂度O(1)**

##### 7.2.3 冒泡排序

每次冒泡的过程，即遍历整个待排序序列，将相邻的两个元素进行比较，如果逆序则交换两者的值，每个元素都访问一遍后完成一次冒泡遍历。首次遍历结束后，顺序最大或最小的元素会被放置在第n个位置上。后续继续遍历其他元素组成的序列，分别放置在n-1,n-2...位置上，直到所有的元素都排序完成。

**稳定排序，时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)**

**PS：冒泡算法稳定的前提是，遇到相同的元素则不进行交换**

##### 7.2.4 简单选择排序

每次选择待排序集合中第i个最小或最大元素，交换排序表中的第i个元素，然后将剩余元素作为待排序集合，继续重复这一过程

**不稳定排序，时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)**

**PS：简单选择算法不稳定的前提是，遇到相同的元素则不进行交换**

##### 7.2.5 快速排序

**快排的主要思想是分治法和递归。**

**不稳定排序，时间复杂度为O(nlog<sub>2</sub>n)，空间复杂度为O(1)**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029232603991.png" alt="image-20221029232603991" style="zoom:67%;" />

##### 7.2.6 堆排序

**不稳定排序，时间复杂度O(nlog<sub>2</sub>n)，空间复杂度O(n)**

**`构建堆的关键要点`：**

1. **可以使用完全二叉树来表示堆**
2. **按照逆序的方式从右往左、自底向上遍历非叶节点，将非叶节点与子树结点进行比较，最大堆取最大，最小堆取最小**
3. **如果交换后，子树不满足堆的排序条件，对子树进行堆的构建**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029231554452.png" alt="image-20221029231554452" style="zoom:67%;" />

**`堆排序的关键要点`：**

1. **每次取出堆顶元素后，都需要将堆底的最后一个元素放置在堆顶，然后进行堆的重构**

##### 7.2.7 归并排序

主要思想是，**将长度为n的数组划分为n个长度为1的数组，并进行两两归并，生成多个有序序列，然后反复将两个有序的序列进行两两归并，最后生成一个完整的有序序列**

**稳定排序，时间复杂度O(nlog<sub>2</sub>n)，空间复杂度O(n)**

##### 7.2.8 基数排序

基数排序的主要思想是按照组成待排序关键字的各个数位（如：个、十、百等）进行排序，而各个数位按照从低到高的顺序，是分配排序的一种。

**稳定排序，时间复杂度O(d(n+rd))，其中d是待排序值的位数，n是待排序数的总个数，r是基数（如十进制则是10），空间复杂度O(rd)**

##### 7.2.9 `排序算法小结`

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029235511884.png" alt="image-20221029235511884" style="zoom:67%;" />

### 8. 程序设计语言与语言处理程序基础

**重点内容：正规式、表达式、传值和传址**

#### 8.1 编译过程

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221029235916992.png" alt="image-20221029235916992" style="zoom:67%;" />

#### 8.2 文法

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030000133680.png" alt="image-20221030000133680" style="zoom:67%;" />

#### 8.3 语法推导树

关键要点在于按照树的层次，分层推导

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030000336534.png" alt="image-20221030000336534" style="zoom:67%;" />

#### 8.4 有限自动机(*)

**有限自动机(Deterministic Finite Automata, DFA)**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030000721676.png" alt="image-20221030000721676" style="zoom:67%;" />

#### 8.5 正规式

有限自动机可到达终态集的另一种表示形式，如(a|ab)*

#### 8.6 表达式

**`解题要点`：**

1. **将表达式视为中序遍历结果，构建对称的二叉树结构**
2. **后缀式，即后序遍历结果；前缀式，即前序遍历结果**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030001507361.png" alt="image-20221030001507361" style="zoom:67%;" />

#### 8.7 函数的调用

**形参(parameter)：函数参数列表中声明的，用于接收值的参数**

**实参(argument)：调用函数时，实际传出值的参数**

#### 8.8 各种程序设计语言的特点

**PS: 其中部分语言都已经很落后了，不再是对应领域的主流**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030002059348.png" alt="image-20221030002059348" style="zoom:80%;" />

### 9. 法律法规

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030002306707.png" alt="image-20221030002306707" style="zoom:50%;" />

#### 9.1 保护期限

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030004528405.png" alt="image-20221030004528405" style="zoom:67%;" />

#### 9.2 知识产权人确定

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030005258640.png" alt="image-20221030005258640" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030005542585.png" alt="image-20221030005542585" style="zoom:67%;" />

#### 9.3 侵权判定(*)

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030005927869.png" alt="image-20221030005927869" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030010436858.png" alt="image-20221030010436858" style="zoom:67%;" />

#### 9.4 标准相关知识

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030010814330.png" alt="image-20221030010814330" style="zoom: 67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030010958729.png" alt="image-20221030010958729" style="zoom:67%;" />

### 10. 多媒体基础

#### 10.1 基础概念

人耳的听力频率范围为20Hz~20KHz，小于这个范围的为次声波，大于这个范围的为超声波。

人说话的声波频率范围为300-3400Hz。

声波的采样，应该为被采样声波最高频率的2倍。

#### 10.2 图像相关概念

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030012256552.png" alt="image-20221030012256552" style="zoom:67%;" />

**CMY指的是印刷三原色**

**灰度，是为了兼容黑白电视机而出现的**

#### 10.3 媒体的种类

**`注意`：分诺依曼体系中的输入设备和输出设备，都属于显示媒体**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030012626650.png" alt="image-20221030012626650" style="zoom:67%;" />

#### 10.4 多媒体计算问题

**图像容量：每帧图片所需要的存储空间大小，乘以对应的图片帧数**

**音频容量：每秒音频所需要的存储空间大小，乘以对应的时间长度**

**视频容量：一段视频所需的存储空间大小，等于一段时间的图片和音频容量之和**

**`解题关键要点`：**

1. **视频容量计算，等于图像容量计算，加上音频容量计算**
2. **每秒音频所需的存储空间大小，等于采样频率\*采样位数（量化位数）\*声道数**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030012811829.png" alt="image-20221030012811829" style="zoom: 67%;" />

#### 10.5 常见多媒体标准

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030150420753.png" alt="image-20221030150420753" style="zoom:67%;" />

#### 10.6 数据压缩基础

压缩数据有一个前提，就是必须保证数据存在冗余才能压缩

无损压缩(lossless compression coding)和有损压缩(loss compression coding)

### 11. 软件工程

#### 11.1 软件开发模型

软件开发模型，也叫软件过程模型

![image-20221030151442495](resources/images/考试学习笔记/image-20221030151442495.png)

##### 11.1.1 瀑布模型和V模型

**软件开发的一个重要特点在于，`想要在软件开发的初期把软件需求完全明确下来，几乎不可能`**

**这也导致，使用瀑布模型，来进行需求不太明确的软件开发工作时，`很可能会导致做出来的东西不是需求方想要的，后续频繁出现返工和重构`**

**瀑布模型（Waterfall Model），`仅适用于需求明确、或者二次开发`（也是需求框架明确）的场景。通常需要结合其他模型，当需求明确后，再使用此模型。**

**`特点`：结构化程度高，不够灵活**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030151548933.png" alt="image-20221030151548933" style="zoom:50%;" />

**V模型**，即可以理解为测试驱动的开发模型，软件开发每个开发阶段开始之前，都先进行对应的测试内容撰写，以便于提前暴露问题，是**瀑布模型的一个变体**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030154529593.png" alt="image-20221030154529593" style="zoom:67%;" />

##### 11.1.2 增量模型

**`（产品）原型`：特指软件产品的原型，通常用于需求分析阶段，以原型为锚点和需求方进行交涉，来敲定需求，`主要用于解决需求不明确的情况`，和瀑布模型形成互补**

**增量模型（Incremental Model）：将整个需求划分为一系列增量产品，整个软件系统划分为多个增量模块，每次完成一个增量模块之后，就让需求方使用和体验，及时收集反馈信息，并进行需求调整，`适用于需求不明确的情况`**

**优点：具备瀑布模型的所有优点，整体风险较小**

**缺点：管理成本高，如果核心需求发生变动，会导致后续的增量可能需要重新开发和发布**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030152731645.png" alt="image-20221030152731645" style="zoom:67%;" />

##### 11.1.3 螺旋模型

**主要特点：**

1. **引入了风险分析**
2. **多种模型的组合**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030153813475.png" alt="image-20221030153813475" style="zoom:67%;" />

##### 11.1.4 喷泉模型

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030154529593.png" alt="image-20221030154529593" style="zoom:67%;" />

##### 11.1.5 构建开发模型

基于构建的开发模型（Component-based Development Model），CBDM

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030160508084.png" alt="image-20221030160508084" style="zoom:67%;" />

##### 11.1.6 统一过程(RP)模型

统一过程(Unified Process)：迭代+增量

阿尔法α测试：在开发环境测试

贝塔β测试：在用户环境测试

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030162358924.png" alt="image-20221030162358924" style="zoom:67%;" />

##### 11.1.7 敏捷开发

**敏捷开发（Agile Development）：`仅适用于小型项目`，采取小步快跑的方式，对于小项目采取比较重型的开发模型，会存在很多不必要的标准化开发环节。**

![image-20221030163520076](resources/images/考试学习笔记/image-20221030163520076.png)

#### 11.2 需求分析

##### 11.2.1 需求分类和需求获取

**需求最初包含业务需求、用户需求、系统需求，产品经理需要和需求方对接这些需求，并将其转换为系统设计时的功能需求、性能需求、设计约束等**

![image-20221030164651090](resources/images/考试学习笔记/image-20221030164651090.png)

#### 11.3 系统设计

##### 11.3.1 基本原则

![image-20221030165239685](resources/images/考试学习笔记/image-20221030165239685.png)

##### 11.3.2 内聚与耦合

**内聚：指的是同一个类型的功能，应该聚集在同一个模块中**

**耦合：指的是，不同的功能模块之间，职责划分要清晰，减少相互依赖**

**高内聚低耦合：即各个模块之间的职责需要划分清晰，面向对象就是这样的一种思想**

![image-20221030165318382](resources/images/考试学习笔记/image-20221030165318382.png)

##### 11.3.3 模块结构

![image-20221030165941789](resources/images/考试学习笔记/image-20221030165941789.png)

##### 11.3.4 数据流图(DDD)

**数据流图，也称为`数据流程图(Data Flow Diagram, DDD)`，它是一种便于用户理解、分析系统数据流程的图形工具。是结构化开发中的主要工具。**

###### 11.3.4.1 数据流图基本概念

**数据流图中的基本图形元素：`数据流（Data Flow）、加工（Process）、数据存储(文件)（Data Store）、外部实体（External Agent）`**

**数据存储：通常是特定的文件、或者表**

![image-20221030233947186](resources/images/考试学习笔记/image-20221030233947186.png)

![image-20221030234040878](resources/images/考试学习笔记/image-20221030234040878.png)

**数据流图的层次模型**

![image-20221030234429445](resources/images/考试学习笔记/image-20221030234429445.png)

###### 11.3.4.2 数据字典(DD)

数据流图描述了系统的分解，但是并没有对图中各个成分进行说明。数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项进行说明。

![image-20221030234622181](resources/images/考试学习笔记/image-20221030234622181.png)

###### 11.3.4.4 数据流图的层次结构

**`顶层图`：分层数据流图的顶层只有一张图，其中只有一个加工（DDD图形元素的一种），代表整个软件系统，该加工描述了软件系统与外界之间的数据流，称为顶层图**

**`0层图`：顶层图中的加工（即系统）经过分解后的图称为0层图，也只有一张**

**底层图：处于分层数据流图最底层的图，称为底层图**

###### 11.3.4.5 分层数据流图的一致性

1. **`父图与子图相应的输入输出一致`**：即子图中各个边界上的输入输出，都应该和父图中对应加工的输入输出的数据流保持一致
2. **数据输入输出守恒**：加工的输入数据流仅存在两个部分，一个部分是用于产生加工的输出数据流，且输出数据流必须完全依赖于输入数据流，一部分则是未使用的数据。
3. **局部数据存储**：任何的数据存储（文件），都应该有读和写的数据流，否则这个文件就没有存在的必要。
4. **加工的输出数据流，不能和输入数据流同名。**

###### 11.3.4.6 分层数据流图的完整性

1. **每个加工至少有一个输入和输出数据流。**如：**黑洞**（只进不出），**奇迹**（只出不进）
2. **每个数据存储应该至少有一个读取数据流、和一个写入数据流**
3. **每个数据流和数据存储必须命名，且与数据字典保持一致**
4. **每个基本加工都应该有一个加工规约**

###### 11.3.4.7 答题技巧

**详细分析试题说明**

**利用分层数据流图的一致性和完整性原则，审视数据流图**

![image-20221030235648589](resources/images/考试学习笔记/image-20221030235648589.png)

**`解题关键要点`：**

1. **首先可以通过题目上下文直接确定外部实体**
2. **`数据存储`，通常是某某表，或者某某文件**

#### 11.4 软件测试

##### 11.4.1 测试原则和类型

**测试应该穿插在整个项目的各个开发环节中**

**回归测试：指的是程序修改之后，所有影响到的已测试内容，都需要重新测试，避免产生新的BUG**

**`测试类型`：动态测试，静态测试**

**动态测试：需要使用工具实现的测试，如黑盒测试、白盒测试、灰盒测试**

**静态测试：人手工进行的测试，如桌前检查、代码走查、代码审查(Code Review)**

![image-20221030170113510](resources/images/考试学习笔记/image-20221030170113510.png)

##### 11.4.2 测试方法和测试用例设计

**黑盒测试**：也被称为**功能测试**，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性

**白盒测试**：也被称为**结构测试**，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检测是否满足设计的需要

**边界值**：指定范围的端点值，以及端点两侧的临近值

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030171317569.png" alt="image-20221030171317569" style="zoom:50%;" />

##### 11.4.3 测试阶段

单元测试->集成测试->确认测试->系统测试

**冒烟测试**：即正式测试之前一次简单但必要的**高等级测试**，主要用于检测软件的一些基本功能，如“程序是否运行”、“用户界面是否打开”。冒烟测试的**目的在于确定程序的问题是否足够细微，是否值得继续更加深入的测试**

**单元测试**：单元测试，也被称为模块测试，在代码编译通过后就可以进行。单元测试是代码中**函数和方法级别的测试**，如面向对象的软件开发，单元测试主要是测试封装在类中的操作和类的状态，即侧重于模块中内部的方法和函数处理逻辑，以及数据结构。

**集成测试**：把模块按系统设计组合来进行测试。一般分为非增量集成、增量集成两种。

**确认测试**：确定功能是否符合需求。

**系统测试**：将软件装载到其需要运行的实际环境，将各个因素结合在一起，进行集成和确认测试。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030172112065.png" alt="image-20221030172112065" style="zoom:67%;" />

#### 11.5 软件度量

##### 11.5.1 软件复杂度度量

**`McCabe度量法`：**

1. **在一个强连通的有向图G中，环的个数V(G)由以下公式给出：`V(G)=m-n+2p`，其中`m是图G中弧的个数`，`n是图G中的结点个数`，`p是图G中强连通分量的个数`**
2. **考试时一般p，即强连通分量的个数，都是1**
3. **`如果有向图分支较多，可以将部分重复的分叉部分抽象为节点进行运算`**

**强连通分量**：如果有向图中某两点能够相互到达，则两点是强连通的，所有结点之间都是强连通的，则称为**强连通图**。若一个有向图的子图，是强连通图，且再添加其他任何一个节点，都会使其变得不是强连通，则称此图为**`极大`强连通子图**，也称为该图的**`强连通分量`**。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030211951663.png" alt="image-20221030211951663" style="zoom:67%;" />

#### 11.6 运行和维护知识

如果在软件设计和实现时，模块间耦合度很高，则会增加系统后期维护成本

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030213735462.png" alt="image-20221030213735462" style="zoom:67%;" />

#### 11.7 信息系统开发方法

结构化法、原型法、面向对象方法、面向服务方法

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030164006603.png" alt="image-20221030164006603" style="zoom:67%;" />

#### 11.8 软件开发过程评级

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030214541647.png" alt="image-20221030214541647" style="zoom:67%;" />

#### 11.9 软件项目管理

**重点在于时间管理、风险管理**

![image-20221030214842167](resources/images/考试学习笔记/image-20221030214842167.png)

##### 11.9.1 时间管理

**PERT图求解`最早和最晚开始时间的关键要点`：**

1. **`终止结点的最早和最晚开始时间默认相同`，在实际场景中终止结点的最晚开始（结束）时间，一般是略微大于最早开始时间的**
2. **正向广度优先遍历，确定各个结点的最早启动时间，求得终止结点的最早和最晚开始时间之后，再逆向求解各个结点的最晚开始时间**

**路径长度：从起点到终点的最长花费时间**

**`关键路径`：具有`最大路径长度`的路径称为关键路径，关键路径上的活动被称为`关键活动`**

![image-20221030215854871](resources/images/考试学习笔记/image-20221030215854871.png)

##### 11.9.2 风险管理

**风险显露度(Risk Exposure, RE)的计算：**

1. **RE=P\*C,P是风险发生的概率，C是风险发生时带来的项目成本**

![image-20221030215956078](resources/images/考试学习笔记/image-20221030215956078.png)

### 12. 面向对象技术

#### 12.1 基本概念

**面向对象(Object-Oriented, OO)=对象(Object)+分类(Classification)+继承(Inheritance)+消息通信(Communication with message)**

#### 12.2 设计原则

**开放-封闭原则(Open & Close Principle)：软件实体（类、模块、函数等）应该是可扩展的，即开放的；但是是不可修改的，即封闭的。即可以允许在不修改原有代码的情况下，对其行为进行扩展**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030222958385.png" alt="image-20221030222958385" style="zoom:67%;" />

#### 12.3 UML图

统一建模语言(Unified Modeling Language，UML)是面向对象软件的标准化建模语言。

**UML的词汇表包含三种构造块**：事物、关系、图

**事物**：结构事物（Structural Thing）、行为事物（Behavior Thing）、分组事物（Grouping Thing）、注释事物（Annotational Thing）

**关系**：依赖（Dependency）、关联（Association）、泛化（Generalization）、实现（Realization）

**图**：类图、对象图、用例图、交互图、状态图、活动图、构件图、组合结构图、部署图、包图

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030224348327.png" alt="image-20221030224348327" style="zoom:67%;" />

##### 12.3.1 用例图

##### 12.3.2 类图

主要考察，类之间的关系，以及聚集关系（包含关系）中的多重度填写，PS：只有聚集关系上才会出现多重度

**类之间的关系图例**：依赖(--->)，泛化（△），聚集（棱形）

**多重度**：包含一个或多个（1..\*），包含零个或多个（0..\*），包含一个（1），包含任意个（\*），等价于包含零个或多个，其中零到1的多重度用0..1表示，即..实际上是标识这是一个省略的范围。

**求解UML类图中聚集关系的多重度时，聚合关系`起点的多重度，代表的是起点类组成终点类时所需的数量描述`；而聚合关系`终点的多重度，代表的是这个起点类属于某个终点类的数量描述`**

##### 12.3.3 顺序图

垂直方向为时间轴，水平方向为各个实体对象

##### 12.3.4 活动图

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101220147317.png" alt="image-20221101220147317" style="zoom:67%;" />

##### 12.3.5 状态图

**以状态为结点**

**状态图的考点通常是查漏补缺，而非绘制具体的图例**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101220205844.png" alt="image-20221101220205844" style="zoom:67%;" />

##### 12.3.6 通信图

和顺序图一样，都是交互图的一种

**通常考点在于查漏补缺，进行填空**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101220349843.png" alt="image-20221101220349843" style="zoom:67%;" />

##### 12.3.7 真题解答

**求解UML类图中聚集关系的多重度时，聚合关系`起点的多重度，代表的是起点类组成终点类时所需的数量描述`；而聚合关系`终点的多重度，代表的是这个起点类属于某个终点类的数量描述`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101220556039.png" alt="image-20221101220556039" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101220620814.png" alt="image-20221101220620814" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101221247612.png" alt="image-20221101221247612" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101221313818.png" alt="image-20221101221313818" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101224346582.png" alt="image-20221101224346582" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101224520720.png" alt="image-20221101224520720" style="zoom:67%;" />

#### 12.4 设计模式

设计模式，可以类比于架构模式、惯用法等

**设计模式的分类：`创建型模型`、`结构型模式`、`行为型模式`**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030225041579.png" alt="image-20221030225041579" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030225701177.png" alt="image-20221030225701177" style="zoom:67%;" />

##### 12.4.1 创建型模式

**创建型模式主要有**：抽象工厂模式(Abstract Factory)、工厂方法模式(Factory Method)、单例模式(Singleton)、构建器(Builder)模式、原型(Prototype)模式

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030225743467.png" alt="image-20221030225743467" style="zoom:67%;" />

##### 12.4.2 结构型模式

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030230519760.png" alt="image-20221030230519760" style="zoom:67%;" />

##### 12.4.3 行为型模式

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030232259481.png" alt="image-20221030232259481" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221030232540960.png" alt="image-20221030232540960" style="zoom:67%;" />

#### 12.5 面向对象程序设计

##### 12.5.1 C++和Java语法要点

Java

import java.util.ArrayList;

class

interface

abstract

implements

##### 12.5.2 真题解答

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221102002535401.png" alt="image-20221102002535401" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221102002837822.png" alt="image-20221102002837822" style="zoom:67%;" />

### 13. 数据库设计

#### 13.1 数据库设计过程

需求分析->概念模型设计->逻辑模型设计->物理模型设计

需求分析阶段的产物：数据流图、数据字典、需求说明书

概念模型设计阶段：主要产出ER模型

逻辑模型设计阶段：将ER模型转换为对应的DBMS支持的关系模型（Relation Model），关系模型是多个若干个关系模式（Relation Schema）的集合。

PS：在数据理论中，关系模型（Relation Model）通常对应着DataBase，而关系模式（Relation Schema）通常对应着Table；而在如今的RDBMS中，Schema通常对应的是Table的一个集合，而非数据库中的关系模式（Relation Schema）概念。

物理模型设计阶段：将逻辑模型转换为对应的物理实现

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221031084459321.png" alt="image-20221031084459321" style="zoom:67%;" />

![image-20221031084459321](resources/images/考试学习笔记/image-20221031084459321.png)

#### 13.2 ER模型

**ER关系类型**：1对1、1对n、m对n

**ER关系转换为关系模式**：

1. 1对1，关系可以独立为关系模式，也可以合并到任意一方
2. 1对n，关系可以独立为关系模式，也可以合并到1的一方
3. m对n，关系只能独立为关系模式

#### 13.3 真题解答

<img src="resources/images/image-20221031090021403.png" alt="image-20221031090021403" style="zoom: 67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221031090021403.png" alt="image-20221031090021403" style="zoom: 67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221031090044907.png" alt="image-20221031090044907" style="zoom:50%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221031090058408.png" alt="image-20221031090058408" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221031090114535.png" alt="image-20221031090114535" style="zoom:50%;" />

**优点：反规范化，减小了查询时联接操作时的运算量，提高了直接查询的效率**

**缺点：同一种权限的描述会在员工表中出现数据冗余存储，并且权限更新时也需要重复更新多条员工表的记录，使得更新变得更加困难**

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101084748424.png" alt="image-20221101084748424" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101084816853.png" alt="image-20221101084816853" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101085042230.png" alt="image-20221101085042230" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101085137578.png" alt="image-20221101085137578" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101085148542.png" alt="image-20221101085148542" style="zoom:67%;" />

### 14. 数据结构及算法应用

#### 14.1 分治算法

分治算法，主要采用分解+递归求子集解+合并子集解的思路进行求解，每次递归结束时，将结果返回给上一层

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101232341655.png" alt="image-20221101232341655" style="zoom:80%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101232705877.png" alt="image-20221101232705877" style="zoom:67%;" />

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101232800766.png" alt="image-20221101232800766" style="zoom:67%;" />

#### 14.2 回溯算法

回溯法，其实常常用于迷宫求解，属于一种暴力求解的搜索算法，注意不要回头重复运算

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101234538245.png" alt="image-20221101234538245" style="zoom:67%;" />

#### 14.3 贪心算法

贪心算法，主要用于求解背包问题。**识别贪心法的主要思路在于，是否是每一步都想取最优**。

背包问题，主要分为01背包问题，和完全背包问题。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101234816000.png" alt="image-20221101234816000" style="zoom:67%;" />

#### 14.4 动态规划算法

动态规划法，和分治算法很类似，也会将一个原始问题划分为多个子问题进行求解。但动态规划法的主要特点在于，会采用某种特定的数据结构，将子集的求解结果进行存储，每次在计算其他的子问题时，会先去访问对应的结构，避免重复计算。

<img src="/resources/images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221101235254251.png" alt="image-20221101235254251" style="zoom:67%;" />

#### 14.5 真题解答