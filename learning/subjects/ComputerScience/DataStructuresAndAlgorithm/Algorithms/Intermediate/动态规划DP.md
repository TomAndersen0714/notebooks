# 动态规划 (Dynamic Programming)

## 算法简介

动态规划（Dynamic Programming）的基本思想是，将原始问题拆分为多个重叠子问题，然后从最简单的子问题开始逐步求解，持久化保存每个子问题的解，最终利用已解决的子问题的解来求解更复杂的子问题，直到解决整个原始问题。

动态规划通过这种从小到大逐步递推，并保存子问题解的方式，能够避免重复计算，并提高算法的效率。

在动态规划中，通常使用状态转移方程（state transfer equation），来描述父问题和子问题之间的联系与求解方法。

在确定最小子问题的解，或者说边界条件（boundary condition）后，通过状态转移方程，就能逐步求得复杂问题的解。通过每次求解后保存当前子问题的解，以避免重复计算，提高效率。

动态规划算法中主要包含以下两个核心部分：
1. **状态转移方程（State Transfer Equation）**
2. **状态缓存（State Cache），或者说 DP 数组**

### 应用场景

动态规划（Dynamic Programming）是一种解决具有“重叠子问题” 和 “最优化子结构”特性的问题的思路或方法，而非具体的算法。“重叠子问题”特性，指的是原始问题可以拆解为多个可以重叠的子问题。“最优子结构”特性，指的是原始问题可以分解为多个子问题，并且可以基于子问题的最优解来求解原始问题的最优解。

### 解题模式

1. 构建 DP 状态转移方程：
	1. 拆解原始问题，将原始问题（或者原始问题求解路径上的某个子问题）拆解为多个之间存在重叠部分（或者说相互依赖）的子问题和父问题，并根据这些问题之间的依赖关系，构建 DP 状态转移方程（State Transfer Equation）。
2. 确定 DP 数组：
	1. 使用 DP 数组的下标来表示这些问题的范围，使用 DP 数组的元素来表示这些相互重叠（或者说相互依赖）的问题的解。
3. 确定 DP 数组的遍历方向：
	1. 根据 DP 状态转移方程，通过绘图将 DP 数组可视化，并给问题解（即元素）之间的依赖链建模，用于确定依赖链中的初始问题，以及问题的依赖链，即 DP 数组的遍历方向。
	2. 一维 DP 数组元素，可以表示为一行并列的方块，可以通过在元素之间绘制连接线条来确定元素之间的依赖链，即遍历方向。
	3. 二维 DP 数组元素，则可以表示为排列为一个正方形的多个方块，可以通过在元素之间绘制连接线条来确定元素之间的依赖链，即遍历方向。
4. 初始化 DP 数组：
	1. 初始化元素默认值：根据具体的问题描述，使用问题的默认解，来初始化 DP 数组元素的值，如有些问题中默认解为-1（可能代表无解时的默认值），即数组元素初始值-1，有些默认解为 0，即数组元素初始值为 0。
	2. 初始化数组边界：根据之前确定的 DP 数组遍历顺序，初始化依赖链中最初始问题的解，后续需要基于这些初始问题的解，逐步依赖链后端的问题的解。
5. 遍历 DP 数组：
	1. 遍历 DP 数组，依据之前确定的 DP 数组遍历方向，求解 DP 数组中每个元素的值，遍历结束后，返回最终结果（有时候也需要边遍历边统计结果）。
	2. 必要时可以打印 DP 数组，确定 DP 元素值符合状态转移方程。

### 与分治的区别和联系

动态规划 (Dynamic Programming) 和分治（Divide and Conquer）的主要区别在于，分治的主要思想是将大问题拆解为互不重叠的子问题进行求解，而动态规划可以处理具备“重叠子问题” 特性的问题。

动态规划和递归（Recursion）算法的主要区别在于，动态规划会使用空间换时间，缓存子问题的解，当后续遇到相同子问题时能直接获取到对应的解。

动态规划算法可以既是迭代（Iteration）算法，也可以是递归（Recursion）算法，主要具备前文提到的核心两个部分，都可以说是动态规划算法。

## 经典例题

### 刷题清单

- [ ] LeetCode416
- [ ] LeetCode509 斐波那契数
- [ ] LeetCode70 爬楼梯
- [ ] LeetCode746 使用最小花费爬楼梯
- [ ] LeetCode62 不同路径
- [ ] LeetCode63 不同路径 2
- [ ] LeetCode343
- [ ] LeetCode96

### 基础题目

70 爬楼梯
509 斐波那契数
746 使用最小花费爬楼梯
62 不同路径
63 不同路径 2
343
96
198 House Robber 房子强盗

### 两点路径问题

两点之间最短路径长度
[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/?envType=study-plan-v2&envId=top-interview-150)
[120. Triangle](https://leetcode.com/problems/triangle/?envType=study-plan-v2&envId=top-interview-150)

两点之间路径数量
[63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

### 背包问题

#### 0/1 背包问题

416
1049
494
474

### 完全背包

518
377
70
322
279
#### 139 词典匹配

问题描述：
- 输入一个字符串，和字典（链表），判断这个字符串能否被拆分为多个字典中的单词，每个单词可以重复使用
注意事项：
- 每个单词可以使用多次
解题思路：
- 动态规划（Dynamic Programming）+递归（Recursion）
	- 使用 Boolean 数组 `dp` 来缓存中间计算结果，假设 `dp[i]` 代表字符串从 i 开始是否可以由单词进行组合，则原始问题可以被转换为 `dp[0]`。
	- 状态转换方程为 `dp[i] = dp[i+n] && s.startWith(word) for word in dictionary`
	- 递归方法的参数列表为 String s、List dictionary、Boolean dp、Int offset，返回值为 Boolean，方法的作用是判断从 offset 开始的字符串是否可以拆分为字典中的单词。

### 打家劫舍

198 打家劫舍
213 打家劫舍 2
337 打家劫舍 3

### 股票问题

121
122
123
188
309
714

### 子序列问题

#### 不连续子序列

##### 300 最长上升子序列


1143 最长公共子序列
1035 不相交的线

#### 连续子序列

674 最长连续递增序列
718 最长重复子数组
53 最大子序列之和

#### 回文字符串

问题概述：
- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
- 查找字符串中最长的回文字符串
问题分析：
1. 回文字符串指的是对称的字符串，既可以是奇数个字符，也可以是偶数个字符
解题思路：
1. 动态规划 Dynamic Process：
	1. 先定义问题的推导公式，即将复杂问题一步步拆解降维为简单问题，然后再反向构建从简单问题到复杂问题的推导公式
	2. 设置简单的问题的已知解，然后用简单问题的已知解，依据推导公式，逐步增加复杂度，求解更复杂的问题
	3. 等所有复杂问题求解完成后，返回最终问题的结果
	4. 但是在本题中，动态规划算法并不是最优的，因为虽然缓存了每个子问题的解，但是每个子问题的解也只使用了一次，复用率不高，因此 DP 算法相比于 BF 算法，并没有什么性能提升。
2. 双指针 Two Pointers (左右指针)

647 回文字符子串数量
516 最长回文子序列

### 正则表达式

[LeetCode 10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

## 参考链接

1. [Wiki-动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
2. [BiliBili-从此再也不怕动态规划了，动态规划解题方法论大曝光](https://www.bilibili.com/video/BV13Q4y197Wg)
3. [BiliBili-动态规划，字符串性质决定了 DP 数组的定义 | LeetCode：647. 回文子串](https://www.bilibili.com/video/BV17G4y1y7z9)
4. [代码随想录](https://programmercarl.com/other/algo_pdf.html)