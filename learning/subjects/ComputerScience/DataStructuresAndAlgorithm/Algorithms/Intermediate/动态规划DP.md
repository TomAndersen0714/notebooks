# 动态规划 (Dynamic Programming)

## 算法简介

动态规划（Dynamic Programming）的基本思想是，将原始问题拆分为多个重叠子问题，然后从最简单的子问题开始逐步求解，持久化保存每个子问题的解，最终利用已解决的子问题的解来求解更复杂的子问题，直到解决整个原始问题。

动态规划通过这种从小到大逐步递推，并保存子问题解的方式，能够避免重复计算，并提高算法的效率。

在动态规划中，通常使用状态转移方程（state transfer equation），来描述父问题和子问题之间的联系与求解方法。

在确定最小子问题的解，或者说边界条件（boundary condition）后，通过状态转移方程，就能逐步求得复杂问题的解。通过每次求解后保存当前子问题的解，以避免重复计算，提高效率。

动态规划算法中主要包含以下两个核心部分：
1. **状态转移方程（State Transfer Equation）**
2. **状态缓存（State Cache），或者说 DP 数组**

### 应用场景

动态规划（Dynamic Programming）是一种解决具有“重叠子问题” 和 “最优化子结构”特性的问题的思路或方法，而非具体的算法。“重叠子问题”特性，指的是原始问题可以拆解为多个可以重叠的子问题。“最优子结构”特性，指的是原始问题可以分解为多个子问题，并且可以基于子问题的最优解来求解原始问题的最优解。

### 解题模式

1. 构建 DP 状态转移方程：
	1. 拆解原始问题，将原始问题（或者原始问题求解路径上的某个子问题）拆解为多个之间存在重叠部分（或者说相互依赖）的子问题和父问题，并根据这些问题之间的依赖关系，定义状态数组中每个元素对应的子问题，并构建 DP 状态转移方程（State Transfer Equation）。
2. 确定 DP 数组：
	1. 使用 DP 数组的下标来表示这些问题的范围，使用 DP 数组的元素来表示这些相互重叠（或者说相互依赖）的问题的解。
3. 确定 DP 数组的遍历方向：
	1. 根据 DP 状态转移方程，通过绘图将 DP 数组可视化，并给问题解（即元素）之间的依赖链建模，用于确定依赖链中的初始问题，以及问题的依赖链，即 DP 数组的遍历方向。
	2. 一维 DP 数组元素，可以表示为一行并列的方块，可以通过在元素之间绘制连接线条来确定元素之间的依赖链，即遍历方向。
	3. 二维 DP 数组元素，则可以表示为排列为一个正方形的多个方块，可以通过在元素之间绘制连接线条来确定元素之间的依赖链，即遍历方向。
4. 初始化 DP 数组：
	1. 初始化元素默认值：根据具体的问题描述，使用问题的默认解，来初始化 DP 数组元素的值，如有些问题中默认解为-1（可能代表无解时的默认值），即数组元素初始值-1，有些默认解为 0，即数组元素初始值为 0。
	2. 初始化数组边界：根据之前确定的 DP 数组遍历顺序，初始化依赖链中最初始问题的解，后续需要基于这些初始问题的解，逐步依赖链后端的问题的解。
5. 遍历 DP 数组：
	1. 遍历 DP 数组，依据之前确定的 DP 数组遍历方向，求解 DP 数组中每个元素的值，遍历结束后，返回最终结果（有时候也需要边遍历边统计结果）。
	2. 必要时可以打印 DP 数组，确定 DP 元素值符合状态转移方程。

其实动态规划算法中的前三步（确定问题、确定方程、确定方向），可以融合为一个步骤“建模”，因为在建模的同时，为了保证建模的准确，前三步一般都需要同时考虑。

### 与分治的区别和联系

动态规划 (Dynamic Programming) 和分治（Divide and Conquer）的主要区别在于，分治的主要思想是将大问题拆解为互不重叠的子问题进行求解，而动态规划可以处理具备“重叠子问题” 特性的问题。

动态规划和递归（Recursion）算法的主要区别在于，动态规划会使用空间换时间，缓存子问题的解，当后续遇到相同子问题时能直接获取到对应的解。

动态规划算法可以既是迭代（Iteration）算法，也可以是递归（Recursion）算法，主要具备前文提到的核心两个部分，都可以说是动态规划算法。

## 经典例题

### 刷题清单

- [ ] LeetCode416
- [ ] LeetCode509 斐波那契数
- [ ] LeetCode70 爬楼梯
- [ ] LeetCode746 使用最小花费爬楼梯
- [ ] LeetCode62 不同路径
- [ ] LeetCode63 不同路径 2
- [ ] LeetCode343
- [ ] LeetCode96

### 基础题目

70 爬楼梯
509 斐波那契数
746 使用最小花费爬楼梯
62 不同路径
63 不同路径 2
343
96
198 House Robber 房子强盗

### 两点路径问题

两点之间最短路径长度
[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/?envType=study-plan-v2&envId=top-interview-150)
[120. Triangle](https://leetcode.com/problems/triangle/?envType=study-plan-v2&envId=top-interview-150)

两点之间路径数量
[63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

### 背包问题

#### 0/1 背包问题

416
1049
494
474

### 完全背包

518
377
70
322
279
#### 139 词典匹配

问题描述：
- 输入一个字符串，和字典（链表），判断这个字符串能否被拆分为多个字典中的单词，每个单词可以重复使用
注意事项：
- 每个单词可以使用多次
解题思路：
- 动态规划（Dynamic Programming）+递归（Recursion）
	- 使用 Boolean 数组 `dp` 来缓存中间计算结果，假设 `dp[i]` 代表字符串从 i 开始是否可以由单词进行组合，则原始问题可以被转换为 `dp[0]`。
	- 状态转换方程为 `dp[i] = dp[i+n] && s.startWith(word) for word in dictionary`
	- 递归方法的参数列表为 String s、List dictionary、Boolean dp、Int offset，返回值为 Boolean，方法的作用是判断从 offset 开始的字符串是否可以拆分为字典中的单词。

### 打家劫舍

198 打家劫舍
213 打家劫舍 2
337 打家劫舍 3

### 股票问题

#### 121，买卖股票最大收益 1，单次买卖

问题描述：输入一维数组，数组中的每个元素代表对应当天的股票价格，返回单次买卖股票的最大收益
注意事项：
1. 只能买一次和买一次
解题思路：
1. 动态规划 Dynamic Programming
	1. 使用 `dp[i]` 代表第 i 天出售股票的最大收益，状态转移方程为 `dp[i] = max { dp[j] + prices[i]-prices[j] for j<i if prices[j] < prices[i] }`，然后从 `dp[0]` 开始遍历到末尾计算所有的状态数组。
	2. 遍历的同时，更新最大利润，然后遍历结束时，即可获取到最大利润。
2. 贪心算法 Greedy
	1. 由于最多只能交易一次，那么到第 i 天卖出股票的最大收益就是在前面股票价格最低时买入。遍历输入这段时间的股票价格，并使用变量记录当前的最小股票价格，然后便能计算出每天的最大股票价格。
	2. 遍历的同时，更新最大利润，然后遍历结束时，即可获取到最大利润。

#### 122，买卖股票最大收益 2，多次买卖

问题描述：输入一维数组，数组中的每个元素代表对应当天的股票价格，返回买卖股票的最大收益
注意事项：
1. 可以买卖无数次，但买入之后必须卖出
解题思路：
1. 贪心算法 Greedy
	1. 由于可以买卖无数次，假设每次间隔一天进行买卖，那么最终的股票收益，就是每次股票上涨产生的收益
	2. 遍历所有股票价格，累加所有的股票上涨利润，即如果当前价格大于前一天，则累加，遍历结束时即可获得最大利润
2. 动态规划 Dynamic Programming
	1. 假设 `dp[i][0]` 代表第 i 天中手里持有股票时的最大收益, `dp[i][1]` 代表第 i 天中手里未持有股票时的最大收益，那么 `dp[i][0] = max {dp[i-1][0], dp[i-1][1] + prices[i]}, dp[i-1][1] = max {dp[i-1][0] - price[i-1], dp[i-1][1]}`
	2. 从第 0 天开始遍历，遍历结束时，`dp[n][0]` 和 `dp[n][1]` 中的最大值，即为最终最大利润

#### 123，买卖股票最大收益 3，两次买卖

问题描述：输入一维数组，数组中的每个元素代表对应当天的股票价格，返回买卖 2 次后股票的最大收益
注意事项：
1. 仅能买卖两次，但买入之后必须卖出
解题思路：
1. 分治算法 Divide + 贪心算法 Greedy
	1. 当前题目的限制是只能进行 2 次买卖，那么可以将当前问题拆解为两个只能进行 1 次买卖的最大利润问题，进而得到 2 次买卖的最大利润。
	2. 遍历所有的价格，每次遍历时，将当天及之前，当天及之后的价格，分别作为 121 买卖股票最大利润问题，进行求解，遍历结束时，即可获得最大利润
	3. 但是此种解法，是存在重复运算的，虽然直观，但并非最佳解法
2. 动态规划 Dynamic Programming
	1. 假设 `dp[3]` 代表当天结束时第 2 次交易卖出股票后的最大利润，`dp[2]` 代表当天结束时第 2 次交易买入股票后的最大利润，`dp[1]` 代表当天结束时第 1 次交易后卖出股票后的最大利润，`dp[0]` 代表当天结束时第 1 次交易买入股票后的最大利润
	2. 初始状态下，当天第 i 天结束时买入时的利润，都等于当天的价格，即 `-price[0]`
	3. 遍历所有价格后，最后的 `dp[3]` 即是本问题的最终结果

#### 188，买卖股票最大收益 4，k 次买卖

问题描述：输入一维数组，以及买卖次数 k，数组中的每个元素代表对应当天的股票价格，返回买卖 k 次后股票的最大收益
注意事项：
1. 买入之后必须卖出
解题思路：
1. 动态规划 Dynamic Programming
	1. 同 123 买卖股票最大收益 3 问题的解法一样，不过在定义状态数组时，建议拆分为 yes（持有），no（未持有）两类数组，然后在遍历时，先初始化持有 yes，再初始化未持有 no。

309
714

### 子序列问题

#### 不连续子序列

##### 300 最长递增子序列

问题描述：
1. 输入一个一维数组，每个元素代表一个数值，返回其能组成的最长递增子序列的长度
2. https://leetcode.com/problems/longest-increasing-subsequence/description
解题思路：
1. 动态规划 Dynamic Programming
	1. 假设 `dp[i]` 代表以 `num[i]` 为结尾的最长递增子序列的长度，则 `dp[0]` 等于 1，`dp[i] = max { dp[j] if nums[i] < nums[j] for j<i}`。
	2. 从头到尾遍历序列，每次更新最大递增子序列长度，遍历结束时，即得到最大值。

##### 1143 最长公共子序列

1035 不相交的线

#### 连续子序列

674 最长连续递增序列
718 最长重复子数组
53 最大子序列之和

#### 回文字符串

问题概述：
- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
- 查找字符串中最长的回文字符串
问题分析：
1. 回文字符串指的是对称的字符串，既可以是奇数个字符，也可以是偶数个字符
解题思路：
1. 动态规划 Dynamic Process：
	1. 先定义问题的推导公式，即将复杂问题一步步拆解降维为简单问题，然后再反向构建从简单问题到复杂问题的推导公式
	2. 设置简单的问题的已知解，然后用简单问题的已知解，依据推导公式，逐步增加复杂度，求解更复杂的问题
	3. 等所有复杂问题求解完成后，返回最终问题的结果
	4. 但是在本题中，动态规划算法并不是最优的，因为虽然缓存了每个子问题的解，但是每个子问题的解也只使用了一次，复用率不高，因此 DP 算法相比于 BF 算法，并没有什么性能提升。
2. 双指针 Two Pointers (左右指针)

647 回文字符子串数量
516 最长回文子序列

### 正则表达式

[LeetCode 10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

### 正方形问题

#### 221，最大正方形面积

问题描述：
1. 输入面积标记矩阵，返回此矩阵中显示的最大正方形面积
解题思路：
1. 动态规划 Dynamic Programming
	1. 本题的关键在于定义状态数组，假设 `dp[i][j]` 代表以 `metrix[i][j]` 为右下角的正方形中面积最大时的边长，则 `dp[i][j] = min { dp[i-1][j],dp[i-1][j-1],dp[i][j-1] } + 1 if matrix[i][j] == '1' else 0`，即当前正方形的变长最长，面积最大。
	2. 通过图形法+穷举法，可以反证此公式，当 `dp[i-1][j-1]` 为 `{dp[i-1][j-1], dp[i][j-1], dp[i-1][j]}` 三者中的最小值时，`{dp[i][j-1], dp[i-1][j]}` 只能等于 `dp[i-1][j-1]`，或者 `dp[i-1][j-1] + 1`，而此时 `dp[i][j] = dp[i-1][j-1] + 1`，同理，当 `{dp[i][j-1], dp[i-1][j]}` 分别为最小值时，不论其他两个值如何变化，最终从图形上来看 dp[i][j] 都等于最小值+1，图形法，最终也可以转换成方程式，来变成书面语言，只是通过图形来穷举，更形象一些。
	3. 初始化第 1 行和第 1 列，然后按行迭代，并更新最大面积，迭代结束时，即得最终结果。

#### 1277，正方形个数

问题描述：
1. 输入面积标记矩阵，返回此矩阵中显示的正方形个数
解题思路：
1. 动态规划 Dynamic Programming
	1. 假设 `dp[i][j]` 代表以 `matrix[i][j]` 为右下角的正方形数量，即 `dp[i][j]` 同时也等于，其变长的最大值，即解题思路同 221 最大正方形面积。
	2. 初始化第 1 行和第 1 列，然后按行迭代，并更新正方形个数，迭代结束时，即得最终结果。

## 参考链接

1. [Wiki-动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
2. [BiliBili-从此再也不怕动态规划了，动态规划解题方法论大曝光](https://www.bilibili.com/video/BV13Q4y197Wg)
3. [BiliBili-动态规划，字符串性质决定了 DP 数组的定义 | LeetCode：647. 回文子串](https://www.bilibili.com/video/BV17G4y1y7z9)
4. [代码随想录](https://programmercarl.com/other/algo_pdf.html)