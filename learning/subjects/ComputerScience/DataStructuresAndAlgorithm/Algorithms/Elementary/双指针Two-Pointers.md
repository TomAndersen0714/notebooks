# 双指针 (Two Pointers)

## 算法简介

双指针算法，是一类用于解决链表、数组、字符串等数据结构问题的常用算法，且通常包含各种变体算法。

### 滑动窗口算法 (Sliding Window)

通过使用两个指针，一个指针指向窗口的起始位置，另一个指针指向窗口的结束位置，两个指针之间保持一定的距离，然后通过滑动窗口来找到满足特定条件的数组或字符串。

### 左右指针算法

两个指针一左一右，相向移动。通过使用两个指针分别指向数组的起始位置和结束位置，根据两个指针指向的元素和目标值之间的关系，来决定下一次的探查方向。

相比于 Brute Force 方法，左右针算法能大幅度减少求解时探查的范围，即针对查找范围进行剪枝。

如：双数求和、回文判断、字符串匹配、二分查找等。

### 快慢指针算法

两个指针一前一后，同向移动，两指针之间不用保持一定的距离。

如：链表回路判断等。

## 经典例题

### K 数求和

#### K=2

##### 双数求和-解唯一

问题概述：
- [LeetCode 1. Two Sum](https://leetcode.com/problems/two-sum/)
- 在一个数组中查找两个数，使得它们的和等于目标值。

前提条件：
1. 解唯一

解题思路：
1. Brute Force：
	1. 双重循环
	2. 时间复杂度为 $O(n^2)$
2. HashMap：
	1. HashMao 存储数组中的数值-索引的键值对
		1. 遍历数组，创建并添加元素。每次添加元素时，检索 Map 中是否包含对应的另一个元素，如果包含则直接输出，否则添加进 Map，继续迭代。
	2. 时间复杂度
		1. 由于 HashMap get/put 方法的平均时间复杂度为 $O(1)$，故整体算法时间复杂度为 $O(n)$

##### 双数求和-有序数组+解唯一

问题概述：
- [LeetCode 167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
- 在一个有序数组中查找两个数，使得它们的和等于目标值。

前提条件：
1. 数组是有序的
2. 解唯一

解题思路：
1. Two pointers：
	1. 方法：将左右指针 left 和 right 的初始位置分别设置为有序数组的起止位置，并假设两指针分别指向结果元组中的最小数 a 和最大数 b。以 left 指针为游标指针，当两指针元素数值之和大于目标值，即 $a+b>target$ 时，则 right 左移 1 位。当满足条件  $a+b<target$ 时，则说明以 left 指针元素为最小元素的所有元组都已遍历完成，故而 left 指针作为游标要右移 1 位，使用下一个值作为元组的最小值，继续遍历，直到出现 $a+b=target$。
	2. 证明 1：
		2. 由条件 1 可得，未发生移动时，$a\leq res[0]$，$b\geq res[1]$；
		3. 由条件 2 可得，在移动过程两个指针的范围在不断缩小，中若某个指针指向了正确答案，即出现 $a=res[0], a+b\geq target$ 或 $b=res[1], a+b\leq target$ 时，即则后续必定会一直移动另一个指针，直到找到正确答案。[参考链接](https://blog.csdn.net/weixin_43445477/article/details/117561685)
	3. 空间复杂度：$O(1)$，时间复杂度： $O(n)$。
2. Binary Search：
	1. 循环，依次检索
	2. 空间复杂度：$O(1)$，时间复杂度： $O(nlog_{2}{n})$。
3. HashMap：
	1. 方法：使用 HashMap 将元素值-元素索引作为 KV 存储。每次遍历时，判断 HashMap 中是否存在另一个 $target-a$，存在则返回对应结果，不存在则
	2. 证明 1：由条件 2 可得，HashMap 中的 Key 不会重复，即结果值唯一。
	3. 空间复杂度：$O(n)$，时间复杂度：$O(n)$。
4. Brute Force：
	1. 双重循环，依次配对

##### 双数求和-输入为 BST

[LeetCode 653. Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)

##### 双数求和-值最接近

问题概述：
- [LeetCode 1099. Two Sum Less Than K](https://leetcode.com/problems/two-sum-less-than-k/)
- [LeetCode 1099. Two Sum Less Than K](https://wentao-shao.gitbook.io/leetcode/two-pointers/1099.two-sum-less-than-k)
- 在一个数组中，查找两个数，使得这两个数之和小于目标值，并返回两数之和的最大值。

前提条件：
1. 目标值大于 0
2. 数组元素也都大于 0

解题思路：
1. Two pointers：
	1. 先排序，后左右指针

#### k=3

##### 三数求和-解不唯一

[LeetCode 15. 3Sum](https://leetcode.com/problems/3sum/)

问题概述：在一个数组中查找三个数，使得它们的和等于目标值，并将所有三元组返回。

前提条件：
1. 解不唯一
2. 解的值不能重复
3. 解的值的索引不能重复

解题思路：
1. 问题降维 + Two pointers：
	1. 方法：根据三个指针指向的元素和目标值之间的关系，先将数组进行排序 Sort，然后遍历数组，假设当前游标指向的元素为结果向量中的最小元素。那么接下来的任务就是判断，游标之后的元素中是否有某两个元素的值之和等于特定值（或满足某特定条件），故而将三数问题，降维转换为了双数问题，从而应用 Two Pointers 进行求解。
	2. 证明：根据条件 1 和条件 2，在移动指针时，为了避免结果中出现重复的解，每次指针移动时，如果移动后指针的元素值和之前相同，则需要不断跳过，避免对应位置使用重复的元素。
	3. 空间复杂度：$O(1)$，时间复杂度： $O(n^2)$。
2. 问题降维 + Binary Search：
	1. 思路：根据三个指针指向的元素和目标值之间的关系，先将数组进行排序 Sort，然后遍历数组，假设当前游标指向的元素为结果向量中的最小元素。那么接下来的任务就是判断，游标之后的元素中是否有某两个元素的值之和等于特定值（或满足某特定条件），故而将三数问题，再次降维转换为了双数问题，从而可以应用 Binary Search 进行求解。

##### 三数求和-值最接近

[LeetCode 16. 3Sum Closest](https://leetcode.com/problems/3sum-closest/)

问题概述：在一个数组中查找三个数，使得它们的和最接近目标值，并返回这三元素之和。

前提条件：
1. 解唯一

解题思路：
1. 问题降维 + Two pointers：
	1. 方法：根据三个指针指向的元素和目标值之间的关系，先将数组进行排序 Sort，然后遍历数组，假设当前游标指向的元素为结果向量中的最小元素。那么接下来的任务就是判断，游标之后的元素中是否有某两个元素的值之和等于特定值（或满足某特定条件），故而将 k=3 三数问题，转换为了 k=2 双数问题，从而应用 Two Pointers 进行求解。
	2. 证明 1：由于条件 1，因此在进行排序 Sort 之后，此问题便变成了多个子问题 [双数求和-值最接近+解不唯一](learning/subjects/ComputerScience/DataStructuresAndAlgorithm/Algorithms/Elementary/双指针Two-Pointers.md#双数求和-值最接近+解不唯一) 。

#### k=4

##### 四数求和

问题概述：
- [LeetCode 18. 4Sum](https://leetcode.com/problems/4sum/)
- 输入一个整型数组，返回所有由其中四个元素构成的子数组组合 Combination，其中所有子数组的元素之和需等于指定值。

返回值要求：
1. 返回答案中的元素顺序可以随意，但组合不能重复

解题思路：
1. 双指针 Two Poiners：
	1. 方法：首先将数组进行排序 Sort，然后将 k 指针逐步依次拆解，简化为 2 Sum 问题进行求解。

注意事项：
1. 在进行数值运算时，要看清题目中给定的条件，是否存在 **整型溢出（Integer Overflow）** 的可能，如果存在溢出可能，建议**直接采用更长的数据类型进行存储**。
2. 要注意**数组中的元素是否可以重复**，如果可能重复，而**题目要求答案中的元素不重复**，则在每次迭代中移动指针之后，**如果指针当前元素和上一个元素相同，则需要跳过当前循环**。

### 字符串子串

#### 最长无重复字符子串

问题概述：
- [- LeetCode](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
- 查找字符串中最长的无重复字符子串
解题思路：
- 双指针 Two Pointers (左右指针)

#### 最长回文字符串

问题概述：
- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
- 查找字符串中最长的回文字符串

问题分析：
1. 回文字符串指的是对称的字符串，既可以是奇数个字符，也可以是偶数个字符

解题思路：
1. 暴力算法 Brute Force：
	1. 直接遍历字符串中的所有字符，遍历时以当前的字符，或者当前和下一个字符作为回文字符串的中心向两边延展，并不断更新结果值。
2. 动态规划 Dynamic Process：
	1. 先定义问题的推导公式，即将复杂问题一步步拆解降维为简单问题，然后再反向构建从简单问题到复杂问题的推导公式
	2. 设置简单的问题的已知解，然后用简单问题的已知解，依据推导公式，逐步增加复杂度，求解更复杂的问题
	3. 等所有复杂问题求解完成后，返回最终问题的结果
	4. 但是在本题中，动态规划算法可能并不是最优的，因为虽然缓存了每个子问题的解，但是每个子问题的解也只使用了一次，复用率不高，因此 DP 算法相比于 BF 算法，并没有什么性能提升。
3. 双指针 Two Pointers (快慢指针)

### 接雨水

问题概述：
- 输入一个数组，要求返回该整个数组作为一个容器时，所能容纳的雨水体积
- [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

### 盛水最多的容器

问题概述：
- 输入一个正数数组，要求返回数组组成的最大容积容器的容积大小
- [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)

解决思路：
- 双指针 Two Pointer
	- 通过不断移动左右双指针，进而找到最大的盛水面积对应的左右边界。在移动左右指针时，只有四种情况
		- 如果移动高的那一边，会有两种情况：
			- 1、下一根柱子的高度比现在高，高度还取最小值低的那边，但宽度变小，最大水量比原来小
			- 2、下一根柱子的高度比现在低，整体高度变小或者不变，但宽度变小，最大水量比原来小
		- 如果移动低的那一边，会有两种情况：
			- 1、下一根柱子的高度比现在高，高度就可以取更高的值，虽然宽度变小，但最大水量不一定比原来小
			- 2、下一根柱子的高度比现在低，整体高度变小或者不变，但宽度变小，最大比原来小
	- 因此虽然移动左右指针的组合很多，但是到达最大容积的路径却只有一条（即一种可能），因此通过每次移动短柱子那边的指针到另一边，必定会经过最大容积的解，

### 链表环路

问题概述：
- 判断链表中是否有环路存储在。

解题思路：
- 快慢指针 Fast Slow Pointers：
	- 通过使用两个指针，一个指针每次移动两步，另一个指针每次移动一步，根据两个指针的位置和关系，判断链表是否有环、找到链表的中间节点等。