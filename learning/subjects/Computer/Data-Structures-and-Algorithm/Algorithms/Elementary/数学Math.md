# 数学 Math


## 取余运算

在 Java 等编程语言中，取余运算符 (%)，支持任意整数和浮点数，充当被除数（dividend）和除数（divisor），如 `-8 % -3`、 `-1.3 % 2`、`2.3 % 2.1` 等，最后的结果被称为余数（remainder）。

其中余数 remainder 的符号，和被除数 dividend 相同，而余数的数值部分，统一等于被除数，以除数为步长，逐渐靠近数轴原点的一个极限距离，如 `-2.3 % 2.1` 的结果约等于 `-0.2`。

### 取余运算的常见应用

#### %2 判断奇偶性

#### %10 取十进制指定位数字

#### %n 判断是否整除

#### %n 取 n 进制指定位数字


## 判断数值溢出

溢出判断的主要思想在于，每次数值执行运算之前，都将变量的当前值，与反向运算后的溢出边界值进行比较，判断在当前值进行对应的运算后，是否会出现溢出。

**编程中最常见的方式是使用更长的数据类型来保存可能溢出的值**，并与原始数据类型的边界值进行比较，进而判断是否溢出。

### 正数溢出判断方法

1. 乘法之前, 则判断是否小于等于 MAX_VALUE/factor，并且大于等于 MIN_VALUE/factor，否则即溢出
2. 加法之前, 则判断是否小于等于 MAX_VALUE-interval，否则即溢出
3. 使用更长的数据类型来保存可能溢出的值，与原始数据类型的边界值进行比较来判断是否溢出

### 负数溢出判断方法

负数也是同理，关键在于溢出的边界值存在不同而已。


## 相关例题


### 反转整数

[LeetCode 7. Reverse Integer](https://leetcode.com/problems/reverse-integer/)

问题概述：将输入的 unsigned 32-bit 的数字进行反转，保留其符号位；如果反转结果溢出，则返回 0，反之则返回反转后的 unsigned 32-bit 数值。

前提条件：
1. 不能使用可以存储 32 bit 以上整型的数据结构

解题思路：
1. Math：
	1. 方法：每次将 x 作为被除数，除 10 取余获得最低位数字 `remainder`，并执行 `x/=x`；然后先判断 y 是否小于等于 `MAX_VALUE/10`，满足则代表不会溢出，然后执行 `y=y*10`；然后再判断 y 是否小于等于 `MAX_VALUE-remainder`，满足则代表不会溢出，然后执行 `y+=remainder`，直到 `x=0` 时，退出循环
	2. 时间复杂度： $O(n)$，空间复杂度：$O(1)$。 



### 位运算

[LeetCode 1356. Sort Integers by The Number of 1 Bits](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/)