# JVM 类加载机制


## JVM 类加载器

Java 中类加载器分为两类，一种是 JVM 内部实现的启动类加载器（Bootstrap Classloader），其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `java.lang.classLoader` 抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。


JVM 运行时，默认创建有三个类加载器：
1. Bootstrap ClassLoader（启动类加载器）：负责加载 `<JAVA_HOME>\lib` 目录中的类。
2. Extension ClassLoader（扩展类加载器）：主要负责加载 `<JAVA_HOME>\lib\ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. Application ClassLoader（应用程序类加载器）：面向我们用户的加载器，负责加载当前应用 `classpath` 下的所有 jar 包和类。


## JVM 类加载的过程


### 加载

1. Java 通过类加载器（Class Loader），通过全类名定位 Java 字节码文件，获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口

### 验证

验证 Java 字节码的安全性，避免非法代码注入。

### 准备

类加载机制中的准备阶段主要是为类变量分配内存空间，并赋初值，基本数据类型赋各自对应的初值，而引用类型变量则初值为 null。

### 解析

解析阶段是虚拟机将常量池内的符号引用（Symbolic References）替换为直接引用（Direct References）的过程。

它包含了被引用元素的名字、描述符等信息，但不包含目标元素的具体内存地址。在 Java 源代码中，当你引用一个类的方法或字段时，这个引用在编译期间会被转化为符号引用。

直接引用是一种在虚拟机运行时期间产生的引用，它包含了能够直接定位到目标的内存地址进而读取信息，可以直接被虚拟机使用。在虚拟机解析类信息时，符号引用会被解析为直接引用，虚拟机会将符号引用转换为能够直接定位目标的指针、偏移量等。


### 初始化

当初始化某个类时，便会执行其中的 static 代码块和 static 赋值语句（被 final 修饰、已经在编译期把结果放入到 class 文件常量池的静态字段除外），且按源码顺序执行。

JVM 初始化 Class 对象的时机：
1. 当虚拟机启动时，用户需要指定一个需要执行的主类（即包含 main 方法的类），虚拟机会先初始化这个类。
2. 最常见的就是使用 new 关键字实例化对象的时候、读取或者设置一个类的静态字段（被 final 修饰、已经在编译期把结果放入到 class 文件常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
3. 当初始化一个子类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
5. 使用 JDK1.7 及之后版本的动态语言支持时的某些特定情况。


## 双亲委派模型

模型：
CustomClassLoader -> AppClassLoader -> ExtensionClassLoader -> BootstrapClassLoader。

JVM 默认情况下：
- ClassLoader 类使用委托模型来搜索类和资源。
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
- ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的。


## 参考链接
1. [微信-JavaGuide-什么是双亲委派模型？](https://mp.weixin.qq.com/s/CCQW0vtr_XZJkjDRKU4jkQ)
2. https://mp.weixin.qq.com/s/CCQW0vtr_XZJkjDRKU4jkQ