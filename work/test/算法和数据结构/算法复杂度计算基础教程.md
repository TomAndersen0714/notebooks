# 算法复杂度计算基础教程


## 数学相关基础知识


### 对数

[对数(Logarithm)](work/note/subject/Math/对数(Logarithm).md)

### 数列和级数

[数列(Sequence)和级数(Series)](work/note/subject/Math/数列(Sequence)和级数(Series).md)

PS: 仿佛快要死去的数学知识突然诈尸


### 渐进记号

https://blog.csdn.net/so_geili/article/details/53353593

#### 渐近紧确界记号Θ

Θ(big-theta)

#### 渐近上界记号O

O(big-oh)

#### 渐近下界记号Ω

Ω(big-omega)

#### 非渐近紧确上界o

o(small-oh)

#### 非渐近紧确下界ω

ω(small-omega)



## 常见的算法复杂度

在实际使用过程中，算法的复杂度一般都是渐进上界(即big-oh)的表达式来表示，其中数据规模n作为表达式的未知数，忽略了常数项和低阶项，只关注随着输入规模增长，算法复杂度的增长趋势，如 $O(n \log n)$。

其中需要注意的是，对数级别的复杂度表达式中，通常都会将 $\log_{2}{n}$ 简写为 $\log{n}$，即$\log_{2}{x} \iff \log{x}$。


### 上确界表达式化简规则

https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7

渐进上界O在计算算法复杂度 $F(n)$ 时常用的化简规则如下：
1. 常数项化简规则：
	1. 如果表达式是常数，则复杂度为$O(c) = O(1)$。
2. 加法化简规则：
	1. 如果函数 $F(n)$ 等结果等价于两个子函数结果之和，可以将它们合并为一个多项式项。
	2. 例如，$O(n^2) + O(n)$，可以简化为$O(n^2) + O(n)=O(n^2 + n) = O(n^2)$。
6. 乘法化简规则：
	1. 如果算法的时间复杂度由多个因子相乘得到，可以将它们合并为一个复合因子。
	2. 例如，$O(n) * O(log n)$，可以简化为$O(n) * O(log n)=O(n log n)$。
3. 对数项化简规则：
	1. 在函数的多项式中，只要底数为常数，反对数为未知数n，皆可通过对数换底公式，和加法化简规则，直接化简为对数阶
	2. 例如，$O(\log_{3/2}{n}) =O(\frac{\log{n}}{\log{(3/2)}}) = O(\log{n})$
4. 常量系数化简规则：
	1. 在函数的多项式，各个项的常数因子可以被省略。
	2. 例如，$O(3n+2n)=O(n+n)=O(n)$。
5. 低阶项化简规则：
	1. 在函数的多项式中，低阶项可以被忽略，仅保留高阶项。
	2. 例如，$O(2n^2 + 3n + 1)$，可以简化为$O(2n^2 + 3n + 1)=O(2n^2) = O(n^2)$。

以下，是几种常见的算法复杂度，及其大小关系，其中对数在没有底数时，统一默认底数为2，即 $\log_{2}{n} \iff \log{(n)}$。
$$
O(1) < O(log(n)) < O(n) < O(nlog(n)) < O(n^2) < O(2^n) < O(n!) < O(n^n) 
$$


### 常数阶O(1)

如一次IF判断

### 线性阶O(n)

如一重循环

### 平方阶O(n^2)

如二重循环

### 指数阶O(2^n)



### 对数阶O(logn)

 其中$\log_{2}{n}$ 简写为了 $\log{n}$，如二分法

### 线性对数阶O(nlogn)

如循环嵌套二分法


## 时间复杂度(Time Complexity)

在计算算法复杂度时，一般使用一个规模为 $n$ 的问题的运行时间 $T(n)$ ，来代表算法的时间复杂度，运行时间 $T(n)$ 的解也通常使用渐进上界（即big-oh）表达式来表示。

### 递归算法

在递归算法中，递归式（recurrence relation），指的是描述递归算法的数学方程式。递归式的定义分为两个部分：基本情况（base case）和递归情况（recursive case）。

例如，某递归算法的时间开销递归方程式如下所示，当n小于或等于1时，递归式的值为常数c。当n大于1时，递归式的值由递归部分和其他项f(n)组成，其中递归部分通过将输入规模缩小到n/b，来进行递归调用，并乘以常数a。
$$
T(n) = \begin{cases}
c, & \text{if } n \leq 1 \\
a \cdot T\left(\frac{n}{b}\right) + f(n), & \text{if } n > 1
\end{cases}
$$

而求解递归式，实际上就是求得这个递归关系式的解析解（closed-form expression），即使用包含未知数的表达式来表示的解，如 $T(n) = O(n \log n)$。而递归式，在数学上，则被称为差分方程式（difference equation），这里就不再展开了。

#### 确定递归方程



#### 求解递归方程


##### 代入法

代入法求解递归式分为两步：
1. 推测出递归式 $T(n)$ 的解析解，其中解析解以问题规模 n 为参数
2. 用数学归纳法求出表达式的常数，并证明解的表达式是正确的

遗憾的是并不存在通用的方法来猜测递归式的正确解，猜测解的表达式，需要凭借经验，偶尔还需要创造力。即使猜出了递归式解的渐近界，也有可能在数学归纳证明时莫名其妙的失败。

正是由于该方法技术细节较为难掌握，只有一些技巧，没有具体准确的实施方法，因此这个方法相比之下并不适合用来求解递归方程，反而比较适合作为其他方法求解结果的检验手段，即在已知使用其他方法求得的解之后，使用数据归纳法来证明解的正确性。

故在此不做总结，具体可以参阅《算法导论》第2章。


##### 递归树法

虽然你可以使用“代入法” 简洁地证明一个解确实是递归式的正确解，但想要直接猜测出递归式的解的表达式形式，依旧十分困难。而“递归树”方法，除了可以是一种用于推测递归关系式解的表达式的方法，当绘制足够精确时，也是一种用于直接求解递归关系式的方法。

在递归树中，每个叶子节点表示某单一子问题的求解代价，非叶子节点代表求解当前子问题时的常数代价，子问题对应某次递归函数的调用。我们将树中每层中的代价求和，得到每层代价，然后将所有层的代价求和，得到所有层次的递归调用的总代价。

使用递归树法求解递归式的步骤：
1. 基于递归式构建递归树
2. 计算树每层开销
3. 计算树深度
4. 基于树的深度、每层开销，计算递归树开销之和


在计算总代价之前，必须要先计算递归树的深度，例如，二分分治的递归树深度为 $\log_{2}{n}$，三分分治的递归树深度为 $\log_{3}{n}$ 。

其中通常会使用到数学中，对数（Logarithm）和级数（Series）计算公式的相关知识，以及渐进上界化简规则。如，常用的对数化简规则，$O(\log_{3/2}{n}) =O(\frac{\log{n}}{\log{(3/2)}}) = O(\log{n})$ 。

##### 主方法



### 非递归算法



## 空间复杂度(Space Complexity)

空间复杂度，和时间复杂度一样，也是用渐进上界（big-oh）来表示算法的空间开销与数据规模之间的增长关系。

其实学会了分析时间复杂度，那么空间复杂度的分析就简单了，主要就看算法当中到底有没有使用到了额外的空间来进行存储数据，然后判断这个额外空间的大小会不会随着 n 的变化而变化，从而得到空间复杂度。


### 递归算法

如果是在递归算法中，则可以通过之前讲到的递归树来分析算法的空间复杂度。


## 参考链接
1. [CSDN-算法导论------递归算法的时间复杂度求解](https://blog.csdn.net/so_geili/article/details/53444816)
2. [CSDN-算法导论------渐近记号Θ、Ο、o、Ω、ω详解](https://blog.csdn.net/so_geili/article/details/53353593)
3. 《算法导论（原书第三版）Introduction to Algorithms.》机械工业出版社，第3章-函数的增长，第4章-分治策略
4. [Wiki-递推关系式](https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F)
5. [Wiki-Recurrence relation](https://en.wikipedia.org/wiki/Recurrence_relation)
6. [Wiki-Closed-form expression](https://en.wikipedia.org/wiki/Closed-form_expression)