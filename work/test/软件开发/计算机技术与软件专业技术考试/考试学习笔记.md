# 软考考前培训笔记

## 软考考试介绍

软考考试是从国外引入的，考的是广度而非深度，与实际开发情况不同

教材只是当做字典翻阅，想要通过考试不能直接翻阅教材，按照视频过一遍知识点和知识体系，然后直接刷真题，了解题型

需要建立知识体系，分版块自查，要学会抓重点，抓弱点

考试形式：上午题，计算机与软件工程知识，150分钟，选择题，75道，满分75分；下午题，软件设计，150分钟，填空、问答题，题型固定。



### 考点表格

**用于自查考试知识点，查漏补缺，抓重点，找弱点**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014091504408.png" alt="image-20221014091504408" style="zoom: 80%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014091709062.png" alt="image-20221014091709062" style="zoom:80%;" />



## 软件设计师考前培训

### 1. 计算机组成与体系结构

#### 1.1 数据的表示



#### 1.2 进制的转换

**R进制转为十进制，使用`按权展开求和法`**，其具体操作为：将R进制数的每一位数值使用R<sup>k</sup>的形式表示，即幂（power）运算的底数是待转换数的进制R，指数为k，k与该数码在原进制数中到其小数点间隔的距离（间隔多少个数字）有关。当该位数码在小数点左边时，k为正，等于与小数点距离的数码个数；在小数点右边时，k为负，绝对值等于与小数点距离的数码个数+1。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093314170.png" alt="image-20221014093314170" style="zoom: 80%;" />

**十进制转换为R进制，使用`短除取余反转法`**，其具体操作如下

**PS：值得注意的是被除数一定要除尽，即最后的商一定要是0，才停止运算。**如下图中，当商为1时，还要继续除以2，商等于0，余数为1，即最后二进制数的首位

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093556127.png" alt="image-20221014093556127" style="zoom:80%;" />



**二进制、八进制、十六进制相互转换**，二进制转八进制，从低位每3位分割，高位补0，每个组合使用**`按权展开求和法`**运算所得，最终结果即为八进制数；二进制转换为十六进制，从低位每4为进行分割，高位补0，每个分割块使用**`按权展开求和法`**所得，并将10~15转换为A~F，最终结果，即为十六进制结果。

**其他进制相互转换**，如M进制数值转换为N进制，则一般是将M进制数值使用**按权展开求和法**转换为10进制数，然后再将其转换为N进制，即使用10进制数作为中间结果。



#### 1.3 原码、反码、补码、移码

**原码**：使用固定数量的字节数表示数值的编码，左边首位bit为符号位，转换时符号位到首个为1的bit位之间，补零进行表示。如数值1，使用2个Byte表示的原码则为`0000 0001`，其中首位为符号位，`0`表示正，`1`表示负数，如数值-1的原码为`1000 0001`

**反码**：反码中，**正数的反码和原码完全相同**；**负数的反码，则是负数的原码转换而来，转换规则为，符号位不动，其他bit位按位取反。**其中，+1(0000 0001)和-1(1111 1110)的反码按位求和结果为`1111 1111`，即对应的原码为`1000 0000`，即为-0

**补码**：补码中，**正数的补码和反码（原码）完全相同**；**`负数的补码，是负数的反码+1所得`。**如-1的反码为`1111 1110`，-1的补码为`1111 1111`，+1的补码为`0000 0001`，+1和-1的补码按位求和结果为`0000 0000`，即为+0

**移码**：**`移码中，正负数的移码都等于其对应补码，将首位符号反转后的结果`**。如-1的补码是`1111 1111`，移码则是`0111 1111`，而+1的移码则是`1000 0001`，两者按位求和的结果为`1000 0000`，即此结果移码对应的原码是`0000 0000`，即为+0

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224303175.png" alt="image-20221017224303175" style="zoom:80%;" />





**各编码表示的数值范围**：

由于补码中，正负0都是使用`0000 0000`表示的（假设为支持使用2 bytes保存），因此其表示的范围要比原码和反码大1个

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224554747.png" alt="image-20221017224554747" style="zoom: 50%;" />



#### 1.4 浮点数运算

个人理解，应该是先将各个浮点数**`采用科学计数法进行格式化`**，然后再进行**`对阶`**，即移动尾数的小数点，增加指数位的值，直到等于各个待求和数值中的指数的最大者，最后再进行**`尾数求和运算`**。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224932472.png" alt="image-20221017224932472" style="zoom:50%;" />





#### 1.5 计算机结构



**冯诺依曼体系结构**：计算机由五个部分组成，分别是**运算器、控制器、存储器、输入设备、输出设备**，并且采用二进制逻辑、程序存储执行。

其中CPU主要由运算器和控制器组成，而**`运算器`主要由算术逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR、状态条件寄存器PSW**等组成，**`控制器`，主要是由程序计数器PC、指令寄存器IR、指令译码器ID、地址寄存器AR、时序部件**等组成。

**PS：指令(instruction), 寄存器(register)，地址(address), 译码器(decoder)**



#### 1.6 Flynn分类法

每个指令流则对应一个控制部分，每个数据流则对应一个处理器

SIMD(Single Instruction Multiple Data)，主要适用于数组运算，即对多个相同数据，使用统一指令进行处理

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017230941961.png" alt="image-20221017230941961" style="zoom: 80%;" />





#### 1.7 CISC与RISC

主要通过选择考察特点，直接理解记忆即可

CISC(Complex Instruction Set Computer, 复杂指令集计算机)

RISC(Reduced Instruction Set Computer, 精简指令集计算机), RISC的基本思想是通过减少指令总和和简化指令功能降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的速度，采用硬布线控制逻辑优化编译程序。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231217404.png" alt="image-20221017231217404" style="zoom: 80%;" />



#### 1.8 流水线和相关计算

类比于福特汽车工厂在组装汽车时，使用流水线的形式进行装配，汽车组装时每个人仅负责流水线上的单个部件安装，然后在流水线上流转到下一个专业员工面前，进行组装工作，提高整体效率。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231940470.png" alt="image-20221017231940470" style="zoom: 67%;" />



1. **流水线执行时间的计算：**

**`流水线的周期`**，其数值一般约**等于流水线上各个部分中，执行时间最长的部分的执行时间**，可以参考木桶原理，流水线上的各个部分需要等待耗时最长的部分结束，才能使得指令在流水线上进行流转

**执行时间计算公式**：

- **`理论公式`**：**`(t1+t2+t3...+ts)+(n-1)*T`**，其中s表示单指令执行的步骤数量，ts表示第s阶段的耗费时间，而n表示流水线上需要处理的总指令数，T表示流水线周期，其中前一部分(t1+t2+t3...+ts)表示首条指令的完成市场，后者(n-1)*T则表示

- **`实践公式`**：**`(s+n-1)*T`**，即将单指令中各个执行部分的执行时间都赋值为执行周期，即最大部分的时间，然后进行计算

理论公式和实践公式的主要区别在于，首个指令的处理时间。在理论公式中，首个指令的处理时间是各个部分的时间之和，而在实践公式中，首个指令则是按照流水线周期乘以

**`优先使用理论公式，没有答案，则使用实践公式计算`**



<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017233527423.png" alt="image-20221017233527423" style="zoom: 67%;" />

2. **流水线吞吐率TP(Though Put Rate)的计算：**

**`TP=指令条数/流水线执行时间`**



3. **流水线的加速比计算**

**`S=不使用流水线的执行时间/使用流水线的执行时间`**

不使用流水线时，则单个指令的执行完成时间，是各个执行部分时间开销的总和(t1+t2+...ts)，而所有指令的完成时间，则是单指令完成时间之和乘以指令数量，即(t1+t2+...ts)*n



4. **流水线的效率（`？？？？`）**

**流水线的效率是指流水线的设备利用率**。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比。

流水线效率的计算公式为：**`E = n个指令或任务占用的时空区/流水线中k个流水段的总的时空区`**

效率最高的流水线，是各个部分的工作时长完全相同，这样就能使得流水线上的任务不会去等待前置任务的结束，没有空闲

**PS：本节中需要学会手动绘制流水线时空图，以辅助理解各个计算公式。流水线效率，即阴影时空区的面积除以时空区总面积**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221019091751343.png" alt="image-20221019091751343" style="zoom: 67%;" />

#### 1.9 层次化存储结构

按照访问速度降序排序：寄存器（CPU）、Cache、内存、外存。一般情况下，存储空间的价格和访问速度成正相关，计算机中其存储空间也和访问速度成正相关。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085101810.png" alt="image-20221020085101810" style="zoom:80%;" />



#### 1.10 Cache

Cache的功能：提高CPU数据输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

在计算机的存储系统体系中，Cache是访问速度最快的层次。（**`寄存器不是最快的吗？？？？？`**）

使用Cache改善系统性能的依据是程序数据访问的局部性原理（locality）



**Cache+主存储器的平均周期计算**：

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085546877.png" alt="image-20221020085546877" style="zoom: 50%;" />

假设读取次数为n，则Cache+主存的读取周期计算公式为t3=(nht1+n(1-h)t2)/n=ht1+(1-h)t2，而不使用缓存的读取周期为t2



#### 1.11 局部性原理

局部性原理，又叫做**访问局部性(Locality of Reference), 数据局部性(Data Locality)**

局部性一般分为两类，空间局部性(spatial locality)和时间局部性(temporal locality)。**空间局部性指的是，访问一个数据之后，访问其存储空间及其临近的数据概率较大；时间局部性指的是，访问一个数据之后，后续临近的时间范围内，再次访问此数据的概率较大**。





#### 1.12 主存

**主存的分类**：

**随机存储存储器(RAM, Random Access Memory):** 断电后，存储内容丢失，如电脑内存

**只读存储器(ROM，Read Only Memory)**: 断点后，存储内容保留，如Bios中的存储器

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020090918987.png" alt="image-20221020090918987" style="zoom: 50%;" />

**主存编址**

**从内存寻址的角度来看：一块内存由许多个`内存地址单元`组成，支持按字节编址（即:8bit），或者按字编址（如:16bit），对应bit数量即为内存的字长，`内存的容量=内存的字长*内存地址单元数量`，内存地址单元数等于最大地址-最小地址+1，其中`内存地址通常为H后缀的16进制数`**

**从内存物理组成的角度来看：一块内存由许多片`存储芯片`组成，而一片存储芯片由多个`存储单元`组成，而每个存储单元，可以存储多个字节或bit位**



**由以上两点可以得出以下内存容量计算公式：**

**`内存的容量 = 内存的字长 * 内存地址单元数量 = 存储芯片数量 * 存储单元数量`**



PS：1K=1024=2^10





#### 1.13 磁盘工作原理

磁盘由磁道、扇区、磁头、磁柱等组成，磁道是磁盘上的一个个圆环，而扇区则是磁盘上的一个个扇形区间，两者共同定位一块磁盘存储物理块

**存取时间 = 寻道时间 + 等待时间(平均定位时间+转动延迟)**

寻道时间是指磁头移动到指定磁道所需的时间；等待时间为等待读写的扇区转动到磁头下方所需的时间。

**解题要点**：

1. **`磁道的磁头在寻址时，只会是朝着同一个方向持续旋转，不会逆向`**
2. **`磁道的磁头在寻址时，可以读取对应的数据写入到缓冲区，读取完成后才会处理缓冲区中的数据，且两者无法同时进行`**
3. **`在处理缓冲区的数据时，磁盘会继续匀速转动，扫描磁道`**
4. **题目中的“`最长时间`”的情况是每次刚刚处理完缓冲区数据时，磁头恰好扫到了下一个待读取扇区的结尾，需要再轮转一圈，才能扫描至其开头进行对应扇区数据的读取；而“`最短时间`”的情况是每次处理完缓冲区数据时，磁头切好扫到了下一个待读取扇区的开头**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020224432013.png" alt="image-20221020224432013" style="zoom:67%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020225809802.png" alt="image-20221020225809802" style="zoom:50%;" />



#### 1.14 计算机总线

**总线：内部总线、系统总线、外部总线**

**系统总线：数据总线、地址总线、控制总线**





#### 1.15 系统可靠性分析

**串联系统模型：**

**`可靠率` = R1\*R2\*R2\*R3...**

**`失效率` = λ1+λ2+λ3+λ4...** 



**并联系统模型：**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020230938442.png" alt="image-20221020230938442" style="zoom: 67%;" />

**模冗余模型：**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020231303278.png" alt="image-20221020231303278" style="zoom: 80%;" />



**`串并联模型`：**

**解题要点：**

1. **注意观察整体是并联还是串联。然后划分各个子模块，计算各个子模块的可靠率**
2. **最后再按照整体的串联或并联公式进行计算整体的可靠率。**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020231330512.png" alt="image-20221020231330512" style="zoom:67%;" />



#### 1.16 校验码

**`码距`：两个二进制码字之间的码距，即两个二进制编码之间不同的bit位**，或者说通过变换二进制bit位，从一个二进制编码变换到另一个二进制编码时，所需要的变换bit位个数。

**检错码：即支持检查错误的编码方案。在一个码字内为了检错e个误码，要求最小的码距应该满足：`d>=e+1`**

**纠错码：即支持纠正错误的编码方案。在一个码字内为了纠错t个误码，则要求最小的码距应该满足：`d>=2t+1`**



**奇校验码和偶校验码：**奇偶校验码是通过在原码指定位置(通常是头部或尾部)添加0或1bit，使得整体bit位的异或结果为1或者0(即数值为1的bit个数为奇数，或者为偶数)



**`循环校验码(Cyclic Check Code, CRC)`: 是检错码，不是纠错码**

**`模2除法`，在除法的基础上，采取不借位的方式，即直接采用异或的方式，代替除法之中的借位和减法**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020234032568.png" alt="image-20221020234032568" style="zoom:67%;" />



**`循环校验码(CRC)的计算`：**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020234748858.png" alt="image-20221020234748858" style="zoom: 50%;" />

**`解题要点`：**

1. **基于`生成多项式`，生成二进制除数**。如生成多项式x^4+x^3+x+1转换成对应的二进制除数为`11011`，
2. 基于除数，**对被除数(即原始编码的二进制形式)进行尾部补零**，补零的个数为除数的位数减一，如除数为`11011`就需要对原始编码的二进制值尾部补4个零
3. **使用模2除法，求得最后的余数**
4. **使用余数的最后几位替换之前原始编码尾部补零的bit位**，最后生成的结果即CRC编码结果



**`校验CRC编码是否正确`:**

**将接收到的CRC编码作为被除数，基于约定的`生成多项式`生成对应的二进制除数，使用除数对被除数进行模2除法，如果最后余数为0，则表示CRC编码的结果是正确的，反之则错误**



**`海明码(Hamming code)?????`: 即是校验码，也是纠错码。海明码存在`校验位`和`信息位`，信息位依次存储原始信息码的bit，校验位则用于校验和纠错，且校验位和信息位的分布是固定的，唯有长度不固定。**

**海明码支持2 bit位的检错，支持1 bit位的纠错**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221021085444721.png" alt="image-20221021085444721" style="zoom:67%;" />

**海明码中`校验码长度满足公式`: `2^r>=x+r+1`，PS：其中r是海明码中校验位长度，x是海明码中二进制信息位的长度**。PS：其中x+r表示其中只有1位bit出错的情况数量，1表示全部正确的情况数量，2^r则表示r位校验位可以表示的所有情况

**海明码中`校验码分布公式`：`Pi = 2^i`，即在从低位开始的序号为2^0,2^1,2^2...的bit位置上，最低位序号为1**

**海明码中`校验位与信息位之间的联系`：若将海明码中各个bit位，从1开始进行二进制编号，则每个校验位的二进制序号可以是`1000, 0100, 0010, 0001`等，即序号的二进制值上只有某个bit为1，而这些校验码等于所有相同bit位上为1的序号，对应的信息位的异或之和，以此就可以列出校验位和信息位之间的`异或关系多项式`。**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221023105125863.png" alt="image-20221023105125863" style="zoom:50%;" />





**`基于信息码计算海明码要点`: **

1. **通过长度计算公式`2^r>=x+r+1`，确定海明码的长度范围，然后选择一个符合的海明码长度，一般取最短**
2. **基于海明码的长度，以及校验码分布公式`Pi = 2^i`，确定海明码中所有信息位和校验位的分布**
3. **基于海明码中`校验位与信息位之间的联系`，列出两者之间异或关系多项式**
4. **对于`异或关系多项式进行求解`，求得各个校验位，将校验位放置于对应位置上，即可求得最终的海明校验码**





### 2. 操作系统

#### 2.1 操作系统的概念

**操作系统的概念及其其主要作用：`进程管理、存储管理、文件管理`、作业管理、设备管理、`微内核操作系统`**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221023105823261.png" alt="image-20221023105823261" style="zoom:67%;" />

#### 2.2 进程的管理

##### 2.2.1 进程的状态

**三态模型，五态模型**，要点在于（人为）挂起和激活会使得进程状态在活跃就绪、活跃阻塞与静止就绪、静止阻塞之间切换。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221024230059378.png" alt="image-20221024230059378" style="zoom: 67%;" />



##### 2.2.2 `前趋图`

**前趋图是用来表示，整个任务中各个环节之间的依赖关系，即有向无环图DAG(Directed Acyclic Graph)**





##### 2.2.3 进程的同步和互斥

同步的反义词是异步，互斥的反义词是共享。

**`互斥`，指的是相同角色之间对于临界资源的竞争；`同步`，指的是不同角色之间的相互等待。**

**以`生产者、缓冲区、消费者`三者举例，缓冲区作为临界资源，每次只能有一个生产者访问缓冲区，即`互斥`；每次生产者给缓冲区填充完成之后，必须等待消费者将其中的数据消费完成后，生产者才能继续填充，这是`同步`**。



##### 2.2.4 pv操作

**临界资源**：诸多相同进程角色间需要互斥方式访问的共享资源，如打印机、独木桥等

**临界区**：每个进程中访问临界资源的一段代码，被称为临界区

**缓冲区资源**：不同进程角色之间可以同时访问的共享资源，如写入缓冲区、桥梁等

**缓冲区：**

**信号量（signal）**：是一种特殊的变量，用于标识和传递特定的信号

**PV操作**：PV操作是由P操作原语和V操作原语组成，而操作的对象则是信号量，如：P(S)代表将信号量S-1，V(S)代表将信号量S+1。



**`PV操作关键要点`**：

1. **在执行P(S)操作后，信号量S+1，若信号量S>=0，则该进程会继续执行后续代码；若信号量S<0，则执行P(S)的进程会被阻塞，并加入到进程等待队列中，等待唤醒。**
2. **在执行V(S)操作后，信号量S-1，若信号量S>0，则该进程会继续执行后续代码；若信号量S<=0，则执行V(S)的进程会被阻塞，并唤醒进程等待队列中的首个生产者进程，让其从阻塞的命令处继续向后执行。**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221024232936770.png" alt="image-20221024232936770" style="zoom:67%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221024233824992.png" alt="image-20221024233824992" style="zoom:67%;" />

**`解题关键要点(？？？？)`**

1. **首先要`区分临界资源和缓冲区资源及其容量`，临界资源的互斥问题，其中PV操作以奇数对出现；缓冲区资源的同步问题，其中的PV操作以偶数对出现。**
2. **`基于PV操作后信号量状态，判断是否符合实际需求`。P操作后，如果S<0，则进入阻塞队列等待，否则继续执行；V操作后，如果S<=0，则唤醒阻塞队列中的首个进程，使其继续执行，否则当前进程继续执行**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025003200526.png" alt="image-20221025003200526" style="zoom:50%;" />

**`PV操作和前趋图组合：`**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025003834432.png" alt="image-20221025003834432" style="zoom:50%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025004205653.png" alt="image-20221025004205653" style="zoom: 67%;" />

##### 2.2.5 死锁问题

**死锁(deadlock)**，如果一个进程在等待一件不可能发生的事情（如：等待一种不可能分配到的资源），则进程出现了死锁。而如果一个或多个进程产生死锁，则会造成系统死锁。

**`系统不会产生死锁的最小资源量计算`：`(n1-1)+(n2-1)+...+(nk-1)+1`，其中k为模块或进程个数，nk表示第k个模块或进程所需的资源数量。**



**死锁产生的四个条件**：

1. 资源互斥
2. 资源保持
3. 资源环路等待
4. 不剥夺其他已分配资源



##### 2.2.6 银行家算法

银行家算法分配资源的原则：

1. 当一个进程对资源的最大需求量不超过系统中的资源数时，可以接纳该进程
2. 进程可以分期请求资源，但请求的总数不能超过最大需求量
3. 当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里面得到资源

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025005144916.png" alt="image-20221025005144916" style="zoom:67%;" />



**`解题关键要点`：**

1. **根据各个进程的最大需求量和已分配资源，`计算进程剩余所需的各类资源`**
2. **根据原有的总资源数，以及各个进程已分配资源，`计算各类资源的剩余资源量`**
3. **通过各类资源的剩余资源量，和进程剩余所需的各类资源量，`筛选能够满足资源需求的进程`**
4. **`使用穷举法`，得出最后的分配方案**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025005958087.png" alt="image-20221025005958087" style="zoom:67%;" />





#### 2.7 存储管理



##### 2.7.1 内存分配

**`内存分配算法`：首次适应算法、最佳适应算法、最差适应算法、循环首次适应算法**

**首次适应算法(first Fit, FF)：将内存的空闲内存块，`按照地址大小升序排序`，确定优先级，当有进程申请内存时，则按照这个顺序，进行内存分配**

**最佳适应算法(best fit, BF)：将内存的空闲内存块，`按照空间大小升序排序`，确定优先级**

**最差适应算法(worst fit, WF)：将内存的空闲内存块，`按照空间大小降序排序`，确定优先级**

**循环首次适应算法(next fit, NF)：在寻找空闲空间时，`不再从表头开始寻找，而是继续从上一次找到的空闲块顺序开始查找`，直到找到第一个块满足的空闲内存块。此算法使得内存空间分布更加均匀，减小了查找空闲空间的开销，缺点是会缺少较大的空闲空间。**





##### 2.7.2 段页式存储

**`考点：`**

1. **逻辑地址和物理地址之间的转换**
2. **页式存储。段式存储、段页式存储的特点，以及运作方式**



###### 2.7.2.1 页式存储

**`逻辑地址`：页号+页内地址，`页表寄存器`：页表起始地址+页表长度，`物理地址`：内存真实的物理地址，`块号/页帧号+页内地址`，如`6A29H`**

**高级程序语言整体使用逻辑地址定位，加载到内存之后，在内存中是使用的是物理地址进行定位**



**`页式存储的作用？？？`**

**特点：**

优点：内存利用率高，碎片小，分配与管理简单

缺点：增加了系统开销，可能存在抖动现象（频繁的缺页中断和磁盘IO）

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025091421734.png" alt="image-20221025091421734" style="zoom:67%;" />

**`解题要点`：**

1. **计算页内地址的二进制长度**：页面大小（如：14K）代表页内地址所能表示的所有地址个数，故通过页面（页表）的大小可以确定其页内地址二进制长度，14K=4*2^10=2^12，即页内地址长度为12bit
2. 基于页内地址的长度，将**逻辑地址拆分为页号和页内地址两个部分**
3. **基于页号查表获取物理块号（页帧号），物理块号与页内地址拼接**，即为内存物理地址
4. **淘汰页面时，优先淘汰访问位为空的**



<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025092921644.png" alt="image-20221025092921644" style="zoom:67%;" />



###### 2.7.2.2 段式存储

**逻辑地址：`段号+段内地址`**





###### 2.7.2.3 段页式存储





###### 2.7.2.4 快表

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025093249913.png" alt="image-20221025093249913" style="zoom:80%;" />



##### 2.7.3 页面淘汰/页面置换算法

**缺页中断**：如果需要访问的内容不在内存中，需要去磁盘中读取和加载，则会发生缺页中断，需要保存当前运行环境，等到需要读取的内容加载完成之后再去恢复。



常见算法，**最优(Optimal, OPT)算法**，随机算法(RAND)

**`先进先出算法(First In First Out, FIFO)`**，当页面空间不足时，可能出现抖动

**`最近最少使用算法(Least Recently Used, LRU)`**，大多数情况下不会出现抖动，即当触发页面淘汰机制时，优先淘汰最久未访问的页面，PS：中文翻译不准确，中文应该翻译为**最久未使用算法**



**`FIFO算法`原理：按照元素访问的先后顺序，有序加入队列，先进入队列的元素，先出队淘汰**

**`LRU算法`原理：每次访问一个元素后，将元素放置于栈顶，后续栈满时，则将栈中最末尾的元素淘汰**



**`解题关键要点`：**

1. 

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025222513148.png" alt="image-20221025222513148" style="zoom:67%;" />



#### 2.8 文件管理

##### 2.8.1 索引文件结构

直接索引、一级索引、二级索引、三级索引



**什么是逻辑块号，什么是物理块号？？？**

逻辑块号是有序的，对应着一段连续的逻辑地址；而物理块号，代表着实际（内存或磁盘）物理存储块的序号，通常无序的



**`解题关键要点`：**

1. **`连续的地址项，指向着一个个物理块的首地址，这些物理块在逻辑上连续，逻辑块号以编号0开始，但实际物理存储上不一定连续，即物理块号不连续`。如地址项iaddr[0]指向的是逻辑块0（的首地址），也是物理块50（的首地址）**
2. **`每个物理块，或者说逻辑块中，可以存放一定容量的信息，可以是索引块，也可以是数据块`。如：索引块和数据块的大小均为1KB大小，地址项大小为4B，则每个物理块（逻辑块）可以存放256个地址项，或者等长的数据**
3. **直接地址索引的索引物理块中存放的是物理块的首地址项，一级索引的索引物理块中，存放的是直接地址索引块的首地址，其他的索引则同样层层递进**
4. **`如果某个地址项，指向的是二级间接索引块，则此索引块中存放的是二级地址索引表`**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025234023249.png" alt="image-20221025234023249" style="zoom: 67%;" />



##### 2.8.2 文件和树形目录结构



**文件属性：只读属性(R)，存档属性(A)，系统文件(S)，隐藏文件(H)**

**文件名的组成：驱动器号、路径、主文件名、扩展名**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221025234656483.png" alt="image-20221025234656483" style="zoom:50%;" />







##### 2.8.3 空闲存储空间的管理

空闲区表法、空闲链表法、**`位图法`**、成组链接法

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026001413515.png" alt="image-20221026001413515" style="zoom:50%;" />

**解题关键要点：**

1. **`字的起始序号是1，而bit位的位置起始序号为0`。都是没道理的，直接记住即可。**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026002026156.png" alt="image-20221026002026156" style="zoom:80%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026002315701.png" alt="image-20221026002315701" style="zoom:50%;" />



#### 2.9 设备管理

##### 2.9.1 数据传输控制方式

程序控制方式、程序中断方式、DMA方式、通道、输入输出处理机

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026002701178.png" alt="image-20221026002701178" style="zoom:67%;" />



##### 2.9.2 虚拟设备和SPOOLING技术

简单来说，就是使用缓存区，来避免资源争抢



##### 2.9.3 微内核操作系统



<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026003349557.png" alt="image-20221026003349557" style="zoom:67%;" />



### 3. 数据库系统



#### 3.1 数据库模式

**`三级模式，两级映射`：外模式、概念模式、内模式；外模式-概念模式映射，概念模式-内模式映射**



**`内模式`，指的是数据库文件(file)的存储方式**

**`概念模式`，指的是数据库中表(table)的存储方式**

**`外模式`，指的是数据库提供给用户的视图(view)展示方式**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026003838351.png" alt="image-20221026003838351" style="zoom:67%;" />







#### 3.2 实体关系(ER)模型

##### 3.2.1 数据库设计过程

需求分析、概念模型、逻辑模型、物理模型

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026004313052.png" alt="image-20221026004313052" style="zoom:67%;" />



**ER图中包含`实体、属性、联系`三种类型模块，分别使用矩形、椭圆形、菱形来表示。联系，可以是1:1，1:n，m:n**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026004629262.png" alt="image-20221026004629262" style="zoom:67%;" />



<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026004653875.png" alt="image-20221026004653875" style="zoom:67%;" />

**关系模式的转换**

**`解题关键要点`：**

1. 可以把关系模式视为数据库表，即一对一联系的实体，至少可以用两张表来存储，其中联系通过id的方式存储在任意一端即可，当然也可以单独存储联系，共使用三张表来表示。而一对多，则至少需要三张表来表示实体和关系。多对多，则也是至少需要三张表来表示实体和关系，否则会发生数据膨胀。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026005153286.png" alt="image-20221026005153286" style="zoom:67%;" />



#### 3.3 关系代数与元组演算



##### 3.3.1 关系代数

**并、交、差、`笛卡尔积、投影、选择、联接`**



**`笛卡尔积`：对两表中各行数据进行嵌套循环拼接，数量等于m\*n**

**`投影`：选择表的某一指定列作为结果**

**`选择`：选择表的某一满足条件的行作为结果**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026010107001.png" alt="image-20221026010107001" style="zoom:50%;" />

**`联接`：在笛卡尔积的计算逻辑基础上，筛选满足指定条件的拼接行作为结果**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221026010203901.png" alt="image-20221026010203901" style="zoom:67%;" />

#### 3.4 规范化理论

##### 3.4.1 函数依赖





#### 3.5 并发控制



#### 3.6 数据库完整性约束



#### 3.7 分布式数据库



#### 3.8 数据仓库和数据挖掘

