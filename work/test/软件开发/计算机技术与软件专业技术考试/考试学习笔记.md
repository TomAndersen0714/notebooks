# 软考考前培训笔记

## 软考考试介绍

软考考试是从国外引入的，考的是广度而非深度，与实际开发情况不同

教材只是当做字典翻阅，想要通过考试不能直接翻阅教材，按照视频过一遍知识点和知识体系，然后直接刷真题，了解题型

需要建立知识体系，分版块自查，要学会抓重点，抓弱点

考试形式：上午题，计算机与软件工程知识，150分钟，选择题，75道，满分75分；下午题，软件设计，150分钟，填空、问答题，题型固定。



### 考点表格

**用于自查考试知识点，查漏补缺，抓重点，找弱点**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014091504408.png" alt="image-20221014091504408" style="zoom: 80%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014091709062.png" alt="image-20221014091709062" style="zoom:80%;" />



## 软件设计师考前培训

### 1. 计算机组成与体系结构

#### 1.1 数据的表示



#### 1.2 进制的转换

**R进制转为十进制，使用`按权展开求和法`**，其具体操作为：将R进制数的每一位数值使用R<sup>k</sup>的形式表示，即幂（power）运算的底数是待转换数的进制R，指数为k，k与该数码在原进制数中到其小数点间隔的距离（间隔多少个数字）有关。当该位数码在小数点左边时，k为正，等于与小数点距离的数码个数；在小数点右边时，k为负，绝对值等于与小数点距离的数码个数+1。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093314170.png" alt="image-20221014093314170" style="zoom: 80%;" />

**十进制转换为R进制，使用`短除取余反转法`**，其具体操作如下

**PS：值得注意的是被除数一定要除尽，即最后的商一定要是0，才停止运算。**如下图中，当商为1时，还要继续除以2，商等于0，余数为1，即最后二进制数的首位

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093556127.png" alt="image-20221014093556127" style="zoom:80%;" />



**二进制、八进制、十六进制相互转换**，二进制转八进制，从低位每3位分割，高位补0，每个组合使用**`按权展开求和法`**运算所得，最终结果即为八进制数；二进制转换为十六进制，从低位每4为进行分割，高位补0，每个分割块使用**`按权展开求和法`**所得，并将10~15转换为A~F，最终结果，即为十六进制结果。

**其他进制相互转换**，如M进制数值转换为N进制，则一般是将M进制数值使用**按权展开求和法**转换为10进制数，然后再将其转换为N进制，即使用10进制数作为中间结果。



#### 1.3 原码、反码、补码、移码

**原码**：使用固定数量的字节数表示数值的编码，左边首位bit为符号位，转换时符号位到首个为1的bit位之间，补零进行表示。如数值1，使用2个Byte表示的原码则为`0000 0001`，其中首位为符号位，`0`表示正，`1`表示负数，如数值-1的原码为`1000 0001`

**反码**：反码中，**正数的反码和原码完全相同**；**负数的反码，则是负数的原码转换而来，转换规则为，符号位不动，其他bit位按位取反。**其中，+1(0000 0001)和-1(1111 1110)的反码按位求和结果为`1111 1111`，即对应的原码为`1000 0000`，即为-0

**补码**：补码中，**正数的补码和反码（原码）完全相同**；**`负数的补码，是负数的反码+1所得`。**如-1的反码为`1111 1110`，-1的补码为`1111 1111`，+1的补码为`0000 0001`，+1和-1的补码按位求和结果为`0000 0000`，即为+0

**移码**：**`移码中，正负数的移码都等于其对应补码，将首位符号反转后的结果`**。如-1的补码是`1111 1111`，移码则是`0111 1111`，而+1的移码则是`1000 0001`，两者按位求和的结果为`1000 0000`，即此结果移码对应的原码是`0000 0000`，即为+0

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224303175.png" alt="image-20221017224303175" style="zoom:80%;" />





**各编码表示的数值范围**：

由于补码中，正负0都是使用`0000 0000`表示的（假设为支持使用2 bytes保存），因此其表示的范围要比原码和反码大1个

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224554747.png" alt="image-20221017224554747" style="zoom: 50%;" />



#### 1.4 浮点数运算

个人理解，应该是先将各个浮点数**`采用科学计数法进行格式化`**，然后再进行**`对阶`**，即移动尾数的小数点，增加指数位的值，直到等于各个待求和数值中的指数的最大者，最后再进行**`尾数求和运算`**。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224932472.png" alt="image-20221017224932472" style="zoom:50%;" />





#### 1.5 计算机结构



**冯诺依曼体系结构**：计算机由五个部分组成，分别是**运算器、控制器、存储器、输入设备、输出设备**，并且采用二进制逻辑、程序存储执行。

其中CPU主要由运算器和控制器组成，而**`运算器`主要由算术逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR、状态条件寄存器PSW**等组成，**`控制器`，主要是由程序计数器PC、指令寄存器IR、指令译码器ID、地址寄存器AR、时序部件**等组成。

**PS：指令(instruction), 寄存器(register)，地址(address), 译码器(decoder)**



#### 1.6 Flynn分类法

每个指令流则对应一个控制部分，每个数据流则对应一个处理器

SIMD(Single Instruction Multiple Data)，主要适用于数组运算，即对多个相同数据，使用统一指令进行处理

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017230941961.png" alt="image-20221017230941961" style="zoom: 80%;" />





#### 1.7 CISC与RISC

主要通过选择考察特点，直接理解记忆即可

CISC(Complex Instruction Set Computer, 复杂指令集计算机)

RISC(Reduced Instruction Set Computer, 精简指令集计算机), RISC的基本思想是通过减少指令总和和简化指令功能降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的速度，采用硬布线控制逻辑优化编译程序。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231217404.png" alt="image-20221017231217404" style="zoom: 80%;" />



#### 1.8 流水线和相关计算

类比于福特汽车工厂在组装汽车时，使用流水线的形式进行装配，汽车组装时每个人仅负责流水线上的单个部件安装，然后在流水线上流转到下一个专业员工面前，进行组装工作，提高整体效率。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231940470.png" alt="image-20221017231940470" style="zoom: 67%;" />



1. **流水线执行时间的计算：**

**`流水线的周期`**，其数值一般约**等于流水线上各个部分中，执行时间最长的部分的执行时间**，可以参考木桶原理，流水线上的各个部分需要等待耗时最长的部分结束，才能使得指令在流水线上进行流转

**执行时间计算公式**：

- **`理论公式`**：**`(t1+t2+t3...+ts)+(n-1)*T`**，其中s表示单指令执行的步骤数量，ts表示第s阶段的耗费时间，而n表示流水线上需要处理的总指令数，T表示流水线周期，其中前一部分(t1+t2+t3...+ts)表示首条指令的完成市场，后者(n-1)*T则表示

- **`实践公式`**：**`(s+n-1)*T`**，即将单指令中各个执行部分的执行时间都赋值为执行周期，即最大部分的时间，然后进行计算

理论公式和实践公式的主要区别在于，首个指令的处理时间。在理论公式中，首个指令的处理时间是各个部分的时间之和，而在实践公式中，首个指令则是按照流水线周期乘以

**`优先使用理论公式，没有答案，则使用实践公式计算`**



<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017233527423.png" alt="image-20221017233527423" style="zoom: 67%;" />

2. **流水线吞吐率TP(Though Put Rate)的计算：**

**`TP=指令条数/流水线执行时间`**



3. **流水线的加速比计算**

**`S=不使用流水线的执行时间/使用流水线的执行时间`**

不使用流水线时，则单个指令的执行完成时间，是各个执行部分时间开销的总和(t1+t2+...ts)，而所有指令的完成时间，则是单指令完成时间之和乘以指令数量，即(t1+t2+...ts)*n



4. **流水线的效率（`？？？？`）**

**流水线的效率是指流水线的设备利用率**。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比。

流水线效率的计算公式为：**`E = n个指令或任务占用的时空区/流水线中k个流水段的总的时空区`**

效率最高的流水线，是各个部分的工作时长完全相同，这样就能使得流水线上的任务不会去等待前置任务的结束，没有空闲

**PS：本节中需要学会手动绘制流水线时空图，以辅助理解各个计算公式。流水线效率，即阴影时空区的面积除以时空区总面积**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221019091751343.png" alt="image-20221019091751343" style="zoom: 67%;" />

#### 1.9 层次化存储结构

按照访问速度降序排序：寄存器（CPU）、Cache、内存、外存。一般情况下，存储空间的价格和访问速度成正相关，计算机中其存储空间也和访问速度成正相关。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085101810.png" alt="image-20221020085101810" style="zoom:80%;" />



#### 1.10 Cache

Cache的功能：提高CPU数据输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

在计算机的存储系统体系中，Cache是访问速度最快的层次。（**`寄存器不是最快的吗？？？？？`**）

使用Cache改善系统性能的依据是程序数据访问的局部性原理（locality）



**Cache+主存储器的平均周期计算**：

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085546877.png" alt="image-20221020085546877" style="zoom: 50%;" />

假设读取次数为n，则Cache+主存的读取周期计算公式为t3=(nht1+n(1-h)t2)/n=ht1+(1-h)t2，而不使用缓存的读取周期为t2



#### 1.11 局部性原理

局部性原理，又叫做**访问局部性(Locality of Reference), 数据局部性(Data Locality)**

局部性一般分为两类，空间局部性(spatial locality)和时间局部性(temporal locality)。**空间局部性指的是，访问一个数据之后，访问其存储空间及其临近的数据概率较大；时间局部性指的是，访问一个数据之后，后续临近的时间范围内，再次访问此数据的概率较大**。





#### 1.12 主存

**主存的分类**：

**随机存储存储器(RAM, Random Access Memory):** 断电后，存储内容丢失，如电脑内存

**只读存储器(ROM，Read Only Memory)**: 断点后，存储内容保留，如Bios中的存储器

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020090918987.png" alt="image-20221020090918987" style="zoom: 50%;" />

**主存编址**

**从内存寻址的角度来看：一块内存由许多个`内存地址单元`组成，支持按字节编址（即:8bit），或者按字编址（如:16bit），对应bit数量即为内存的字长，`内存的容量=内存的字长*内存地址单元数量`，内存地址单元数等于最大地址-最小地址+1，其中内存地址通常为H后缀的16进制数**

**从内存物理组成的角度来看：一块内存由许多片`存储芯片`组成，而一片存储芯片由多个`存储单元`组成，而每个存储单元，可以存储多个字节或bit位**



**由以上两点可以得出以下内存容量计算公式：**

**`内存的容量 = 内存的字长 * 内存地址单元数量 = 存储芯片数量 * 存储单元数量`**



PS：1K=1024=2^10





#### 1.13 磁盘工作原理

磁盘由磁道、扇区、磁头、磁柱等组成，磁道是磁盘上的一个个圆环，而扇区则是磁盘上的一个个扇形区间，两者共同定位一块磁盘存储物理块

**存取时间 = 寻道时间 + 等待时间(平均定位时间+转动延迟)**

寻道时间是指磁头移动到指定磁道所需的时间；等待时间为等待读写的扇区转动到磁头下方所需的时间。

**解题要点**：

1. **`磁道的磁头在寻址时，只会是朝着同一个方向持续旋转，不会逆向`**
2. **`磁道的磁头在寻址时，可以读取对应的数据写入到缓冲区，读取完成后才会处理缓冲区中的数据，且两者无法同时进行`**
3. **`在处理缓冲区的数据时，磁盘会继续匀速转动，扫描磁道`**
4. **题目中的“`最长时间`”的情况是每次刚刚处理完缓冲区数据时，磁头恰好扫到了下一个待读取扇区的结尾，需要再轮转一圈，才能扫描至其开头进行对应扇区数据的读取；而“`最短时间`”的情况是每次处理完缓冲区数据时，磁头切好扫到了下一个待读取扇区的开头**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020224432013.png" alt="image-20221020224432013" style="zoom:67%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020225809802.png" alt="image-20221020225809802" style="zoom:50%;" />



#### 1.14 计算机总线

**总线：内部总线、系统总线、外部总线**

**系统总线：数据总线、地址总线、控制总线**





#### 1.15 系统可靠性分析

**串联系统模型：**

**`可靠率` = R1\*R2\*R2\*R3...**

**`失效率` = λ1+λ2+λ3+λ4...** 



**并联系统模型：**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020230938442.png" alt="image-20221020230938442" style="zoom: 67%;" />

**模冗余模型：**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020231303278.png" alt="image-20221020231303278" style="zoom: 80%;" />



**`串并联模型`：**

**解题要点：**

1. **注意观察整体是并联还是串联。然后划分各个子模块，计算各个子模块的可靠率**
2. **最后再按照整体的串联或并联公式进行计算整体的可靠率。**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020231330512.png" alt="image-20221020231330512" style="zoom:67%;" />



#### 1.16 校验码

**`码距`：两个二进制码字之间的码距，即两个二进制编码之间不同的bit位**，或者说通过变换二进制bit位，从一个二进制编码变换到另一个二进制编码时，所需要的变换bit位个数。

**检错码：即支持检查错误的编码方案。在一个码字内为了检错e个误码，要求最小的码距应该满足：`d>=e+1`**

**纠错码：即支持纠正错误的编码方案。在一个码字内为了纠错t个误码，则要求最小的码距应该满足：`d>=2t+1`**



**奇校验码和偶校验码：**奇偶校验码是通过在原码指定位置(通常是头部或尾部)添加0或1bit，使得整体bit位的异或结果为1或者0(即数值为1的bit个数为奇数，或者为偶数)



**`循环校验码(Cyclic Check Code, CRC)`: 是检错码，不是纠错码**

**`模2除法`，在除法的基础上，采取不借位的方式，即直接采用异或的方式，代替除法之中的借位和减法**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020234032568.png" alt="image-20221020234032568" style="zoom:67%;" />



**`循环校验码(CRC)的计算`：**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020234748858.png" alt="image-20221020234748858" style="zoom: 50%;" />

**`解题要点`：**

1. **基于`生成多项式`，生成二进制除数**。如生成多项式x^4+x^3+x+1转换成对应的二进制除数为`11011`，
2. 基于除数，**对被除数(即原始编码的二进制形式)进行尾部补零**，补零的个数为除数的位数减一，如除数为`11011`就需要对原始编码的二进制值尾部补4个零
3. **使用模2除法，求得最后的余数**
4. **使用余数的最后几位替换之前原始编码尾部补零的bit位**，最后生成的结果即CRC编码结果



**`校验CRC编码是否正确`:**

**将接收到的CRC编码作为被除数，基于约定的`生成多项式`生成对应的二进制除数，使用除数对被除数进行模2除法，如果最后余数为0，则表示CRC编码的结果是正确的，反之则错误**



**`海明码(Hamming code)`: 即是校验码，也是纠错码。海明码存在`校验位`和`信息位`，信息位依次存储原始信息码的bit，校验位则用于校验和纠错，且校验位和信息位的分布是固定的，唯有长度不固定。**

**海明码支持2 bit位的检错，支持1 bit位的纠错**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221021085444721.png" alt="image-20221021085444721" style="zoom:67%;" />

**海明码中`校验码长度满足公式`: `2r>=x+r+1`，PS：其中r是海明码的长度，x是二进制信息码的长度**。PS：其中x+r表示其中

**海明码中`校验码分布公式`：`2^n`，即在从低位开始的序号为2^0,2^1,2^2...的bit位置上，最低位序号为1**

**海明码中`信息位和校验位之间值的关系公式`：**





**`基于信息码字计算海明码要点`: **

1. **通过长度计算公式`2r>=x+r+1`，确定海明码的长度范围，然后选择一个符合的海明码长度，一般取最短**
2. **基于海明码的长度，确定海明码所有信息位和校验位的分布**



