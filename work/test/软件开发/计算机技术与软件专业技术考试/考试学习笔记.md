# 软考考前培训笔记

## 软考考试介绍

软考考试是从国外引入的，考的是广度而非深度，与实际开发情况不同

教材只是当做字典翻阅，想要通过考试不能直接翻阅教材，按照视频过一遍知识点和知识体系，然后直接刷真题，了解题型

需要建立知识体系，分版块自查，要学会抓重点，抓弱点

考试形式：上午题，计算机与软件工程知识，150分钟，选择题，75道，满分75分；下午题，软件设计，150分钟，填空、问答题，题型固定。



### 考点表格

**用于自查考试知识点，查漏补缺，抓重点，找弱点**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014091504408.png" alt="image-20221014091504408" style="zoom: 80%;" />

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014091709062.png" alt="image-20221014091709062" style="zoom:80%;" />



## 软件设计师考前培训

### 1. 计算机组成与体系结构

#### 1.1 数据的表示



##### 1.1.1 进制的转换

**R进制转为十进制，使用`按权展开求和法`**，其具体操作为：将R进制数的每一位数值使用R<sup>k</sup>的形式表示，即幂（power）运算的底数是待转换数的进制R，指数为k，k与该数码在原进制数中到其小数点间隔的距离（间隔多少个数字）有关。当该位数码在小数点左边时，k为正，等于与小数点距离的数码个数；在小数点右边时，k为负，绝对值等于与小数点距离的数码个数+1。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093314170.png" alt="image-20221014093314170" style="zoom: 80%;" />

**十进制转换为R进制，使用`短除取余反转法`**，其具体操作如下

**PS：值得注意的是被除数一定要除尽，即最后的商一定要是0，才停止运算。**如下图中，当商为1时，还要继续除以2，商等于0，余数为1，即最后二进制数的首位

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221014093556127.png" alt="image-20221014093556127" style="zoom:80%;" />



**二进制、八进制、十六进制相互转换**，二进制转八进制，从低位每3位分割，高位补0，每个组合使用**`按权展开求和法`**运算所得，最终结果即为八进制数；二进制转换为十六进制，从低位每4为进行分割，高位补0，每个分割块使用**`按权展开求和法`**所得，并将10~15转换为A~F，最终结果，即为十六进制结果。

**其他进制相互转换**，如M进制数值转换为N进制，则一般是将M进制数值使用**按权展开求和法**转换为10进制数，然后再将其转换为N进制，即使用10进制数作为中间结果。



##### 1.1.2 原码、反码、补码、移码

**原码**：使用固定数量的字节数表示数值的编码，左边首位bit为符号位，转换时符号位到首个为1的bit位之间，补零进行表示。如数值1，使用2个Byte表示的原码则为`0000 0001`，其中首位为符号位，`0`表示正，`1`表示负数，如数值-1的原码为`1000 0001`

**反码**：反码中，**正数的反码和原码完全相同**；**负数的反码，则是负数的原码转换而来，转换规则为，符号位不动，其他bit位按位取反。**其中，+1(0000 0001)和-1(1111 1110)的反码按位求和结果为`1111 1111`，即对应的原码为`1000 0000`，即为-0

**补码**：补码中，**正数的补码和反码（原码）完全相同**；**`负数的补码，是负数的反码+1所得`。**如-1的反码为`1111 1110`，-1的补码为`1111 1111`，+1的补码为`0000 0001`，+1和-1的补码按位求和结果为`0000 0000`，即为+0

**移码**：**`移码中，正负数的移码都等于其对应补码，将首位符号反转后的结果`**。如-1的补码是`1111 1111`，移码则是`0111 1111`，而+1的移码则是`1000 0001`，两者按位求和的结果为`1000 0000`，即此结果移码对应的原码是`0000 0000`，即为+0

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224303175.png" alt="image-20221017224303175" style="zoom:80%;" />





**各编码表示的数值范围**：

由于补码中，正负0都是使用`0000 0000`表示的（假设为支持使用2 bytes保存），因此其表示的范围要比原码和反码大1个

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224554747.png" alt="image-20221017224554747" style="zoom: 50%;" />



##### 1.1.3 浮点数运算

个人理解，应该是先将各个浮点数**`采用科学计数法进行格式化`**，然后再进行**`对阶`**，即移动尾数的小数点，增加指数位的值，直到等于各个待求和数值中的指数的最大者，最后再进行**`尾数求和运算`**。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017224932472.png" alt="image-20221017224932472" style="zoom:50%;" />





##### 1.1.4 计算机结构



**冯诺依曼体系结构**：计算机由五个部分组成，分别是**运算器、控制器、存储器、输入设备、输出设备**，并且采用二进制逻辑、程序存储执行。

其中CPU主要由运算器和控制器组成，而**`运算器`主要由算术逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR、状态条件寄存器PSW**等组成，**`控制器`，主要是由程序计数器PC、指令寄存器IR、指令译码器ID、地址寄存器AR、时序部件**等组成。

**PS：指令(instruction), 寄存器(register)，地址(address), 译码器(decoder)**



##### 1.1.5 Flynn分类法

每个指令流则对应一个控制部分，每个数据流则对应一个处理器

SIMD(Single Instruction Multiple Data)，主要适用于数组运算，即对多个相同数据，使用统一指令进行处理

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017230941961.png" alt="image-20221017230941961" style="zoom: 80%;" />





##### 1.1.6 CISC与RISC

主要通过选择考察特点，直接理解记忆即可

CISC(Complex Instruction Set Computer, 复杂指令集计算机)

RISC(Reduced Instruction Set Computer, 精简指令集计算机), RISC的基本思想是通过减少指令总和和简化指令功能降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的速度，采用硬布线控制逻辑优化编译程序。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231217404.png" alt="image-20221017231217404" style="zoom: 80%;" />



##### 1.1.7 流水线和相关计算

类比于福特汽车工厂在组装汽车时，使用流水线的形式进行装配，汽车组装时每个人仅负责流水线上的单个部件安装，然后在流水线上流转到下一个专业员工面前，进行组装工作，提高整体效率。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017231940470.png" alt="image-20221017231940470" style="zoom: 67%;" />



1. **流水线执行时间的计算：**

**`流水线的周期`**，其数值一般约**等于流水线上各个部分中，执行时间最长的部分的执行时间**，可以参考木桶原理，流水线上的各个部分需要等待耗时最长的部分结束，才能使得指令在流水线上进行流转

**执行时间计算公式**：

- **`理论公式`**：**`(t1+t2+t3...+ts)+(n-1)*T`**，其中s表示单指令执行的步骤数量，ts表示第s阶段的耗费时间，而n表示流水线上需要处理的总指令数，T表示流水线周期，其中前一部分(t1+t2+t3...+ts)表示首条指令的完成市场，后者(n-1)*T则表示

- **`实践公式`**：**`(s+n-1)*T`**，即将单指令中各个执行部分的执行时间都赋值为执行周期，即最大部分的时间，然后进行计算

理论公式和实践公式的主要区别在于，首个指令的处理时间。在理论公式中，首个指令的处理时间是各个部分的时间之和，而在实践公式中，首个指令则是按照流水线周期乘以

**`优先使用理论公式，没有答案，则使用实践公式计算`**



<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221017233527423.png" alt="image-20221017233527423" style="zoom: 67%;" />

2. **流水线吞吐率TP(Though Put Rate)的计算：**

**`TP=指令条数/流水线执行时间`**



3. **流水线的加速比计算**

**`S=不使用流水线的执行时间/使用流水线的执行时间`**

不使用流水线时，则单个指令的执行完成时间，是各个执行部分时间开销的总和(t1+t2+...ts)，而所有指令的完成时间，则是单指令完成时间之和乘以指令数量，即(t1+t2+...ts)*n



4. **流水线的效率（`？？？？`）**

**流水线的效率是指流水线的设备利用率**。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比。

流水线效率的计算公式为：**`E = n个指令或任务占用的时空区/流水线中k个流水段的总的时空区`**

效率最高的流水线，是各个部分的工作时长完全相同，这样就能使得流水线上的任务不会去等待前置任务的结束，没有空闲

**PS：本节中需要学会手动绘制流水线时空图，以辅助理解各个计算公式。流水线效率，即阴影时空区的面积除以时空区总面积**

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221019091751343.png" alt="image-20221019091751343" style="zoom: 67%;" />

##### 1.1.8 层次化存储结构

按照访问速度降序排序：寄存器（CPU）、Cache、内存、外存。一般情况下，存储空间的价格和访问速度成正相关，计算机中其存储空间也和访问速度成正相关。

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085101810.png" alt="image-20221020085101810" style="zoom:80%;" />



##### 1.1.9 Cache

Cache的功能：提高CPU数据输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。

在计算机的存储系统体系中，Cache是访问速度最快的层次。（**`寄存器不是最快的吗？？？？？`**）

使用Cache改善系统性能的依据是程序数据访问的局部性原理（locality）



**Cache+主存储器的平均周期计算**：

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020085546877.png" alt="image-20221020085546877" style="zoom: 50%;" />

假设读取次数为n，则Cache+主存的读取周期计算公式为t3=(nht1+n(1-h)t2)/n=ht1+(1-h)t2，而不使用缓存的读取周期为t2



##### 1.1.10 局部性原理

局部性原理，又叫做**访问局部性(Locality of Reference), 数据局部性(Data Locality)**

局部性一般分为两类，空间局部性(spatial locality)和时间局部性(temporal locality)。**空间局部性指的是，访问一个数据之后，访问其存储空间及其临近的数据概率较大；时间局部性指的是，访问一个数据之后，后续临近的时间范围内，再次访问此数据的概率较大**。





##### 1.1.11 主存

**主存的分类**：

**随机存储存储器(RAM, Random Access Memory):** 断电后，存储内容丢失，如电脑内存

**只读存储器(ROM，Read Only Memory)**: 断点后，存储内容保留，如Bios中的存储器

<img src="images/%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221020090918987.png" alt="image-20221020090918987" style="zoom: 50%;" />

**主存编址（`？？？？`）**：

每个**内存地址**，都对应着单个**地址单元**。内存地址通常以H为标志结尾，以16进制编码作为前缀进行编号。两个内存地址之间的地址单元个数，即末地址减去首地址+1。**`每个存储芯片上分布着多个存储单元，每个存储单元可以存储多个bit位`**。

PS：1K=1024=2^10



